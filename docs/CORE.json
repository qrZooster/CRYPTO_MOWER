{
  "meta": {
    "project": "CRYPTO_MOWER",
    "part": "CORE",
    "updated": "2025-10-19T08:25:54Z",
    "files_count": 5
  },
  "files": [
    {
      "name": "bb_controls.py",
      "dir": "/core",
      "lines": 190,
      "bytes": 7272,
      "updated": "2025-10-18T14:04:07Z",
      "content": "# ============================================================\n# bb_controls.py ‚Äî –≤–∏–∑—É–∞–ª—å–Ω–∞—è –≤–µ—Ç–≤—å Tradition Core 2025\n# created: 17.10.2025 12:31\n# –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç TCustomControl, TControl, TForm, TPage\n# ============================================================\nfrom __future__ import annotations\nfrom typing import Optional, Dict\nfrom bb_sys import *\n# ---------------------------------------------------------------------\n# TCustomControl ‚Äî –±–∞–∑–æ–≤—ã–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç\n# ---------------------------------------------------------------------\nclass TCustomControl(TComponent):\n    def __init__(self, Owner=None, Name=None, Parent=None):\n        super().__init__(Owner, Name)\n        self.Parent = Parent\n        self.Controls: dict[str, \"TCustomControl\"] = {}\n        self.src: list[str | \"TCustomControl\"] = []\n        if Parent:\n            Parent.add_control(self)\n        self.log(\"__init__\", f\"visual control {self.Name} created\")\n\n    def add_control(self, ctrl: \"TCustomControl\"):\n        if ctrl.Name in self.Controls:\n            self.fail(\"add_control\", f\"duplicate control {ctrl.Name}\", ValueError)\n        self.Controls[ctrl.Name] = ctrl\n        ctrl.Parent = self\n        self.src.append(ctrl)\n\n    def control(self, ctrl: \"TCustomControl\"):\n        if ctrl.Name in self.Controls:\n            self.fail(\"control\", f\"duplicate control {ctrl.Name}\", ValueError)\n        self.Controls[ctrl.Name] = ctrl\n        ctrl.Parent = self\n        self.src.append(ctrl)\n        return ctrl\n\n    def text(self, html: str):\n        self.src.append(str(html))\n\n    def tg(self, tag: str, cls: str | None = None, attr: str | None = None):\n        cls_part = f\" class='{cls}'\" if cls else \"\"\n        attr_part = f\" {attr}\" if attr else \"\"\n        self.text(f\"<{tag}{cls_part}{attr_part}>\")\n\n    def etg(self, tag: str):\n        self.text(f\"</{tag}>\")\n\n    def br(self, count: int = 1):\n        try:\n            n = max(0, int(count))\n        except Exception:\n            n = 1\n        if n > 0:\n            self.src.append(\"<br/>\" * n + \"\\n\")\n\n    def h(self, count: int = 1, s: str | None = None, cls: str | None = None, attr: str | None = None):\n        try:\n            n = max(1, min(6, int(count)))\n        except Exception:\n            n = 1\n        self.tg(f\"h{n}\", cls, attr)\n        if s is not None:\n            self.text(s)\n        self.etg(f\"h{n}\")\n\n    # —Ñ–∞—Å–∞–¥—ã (—Å–∞—Ö–∞—Ä)\n    def div(self, cls=None, attr=None):self.tg(\"div\", cls, attr)\n    def ediv(self):self.etg(\"div\")\n    def table(self, cls=None, attr=None):self.tg(\"table\", cls, attr)\n    def etable(self):self.etg(\"table\")\n    def tr(self, cls=None, attr=None):self.tg(\"tr\", cls, attr)\n    def etr(self):self.etg(\"tr\")\n    def td(self, cls=None, attr=None):self.tg(\"td\", cls, attr)\n    def etd(self):self.etg(\"td\")\n\n    def _tg(self, tg: str, src: str):\n        \"\"\"–û–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç src –≤ —Ç–µ–≥ tg.\"\"\"\n        self.tg(tg)\n        self.text(src)\n        self.etg(tg)\n\n    def html(self) -> str:\n        out = []\n        for item in self.src:\n            if isinstance(item, TCustomControl):\n                out.append(item.html())\n            else:\n                out.append(str(item))\n        return \"\".join(out)\n# ---------------------------------------------------------------------\n# TControl ‚Äî –æ–±—ã—á–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (div, span, button –∏ —Ç.–¥.)\n# ---------------------------------------------------------------------\nclass TControl(TCustomControl):\n    def __init__(self, Owner=None, Name=None, Parent=None, tag=\"div\", text=\"\"):\n        super().__init__(Owner, Name, Parent)\n        self.log(\"__init__\", f\"control {self.Name}  created\")\n# ---------------------------------------------------------------------\n# TPage ‚Äî –∫–æ—Ä–Ω–µ–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (HTML-—É—Ä–æ–≤–µ–Ω—å)\n# ---------------------------------------------------------------------\nclass TPage(TCustomControl):\n    def __init__(self, Owner, Name=\"page\", title=\"New Page\"):\n        super().__init__(Owner, Name)\n        self.title = title\n        self.Parent = None\n        self.style = \"\"\n        self.log(\"__init__\", f\"page {self.Name} created\")\n\n    def html(self):\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª–Ω—ã–π HTML-–¥–æ–∫—É–º–µ–Ω—Ç Tradition Core.\"\"\"\n        body = super().html()\n        self.src = []\n        self.text(\"<!DOCTYPE html>\\n\")\n        self.tg(\"html\", None, 'lang=\"en\"')\n        self.tg(\"head\")\n        self.text('<meta charset=\"UTF-8\">\\n')\n        self._tg(\"title\", self.title)\n        self._tg(\"style\", self.style)\n        self.etg(\"head\")\n        self._tg(\"body\", body)\n        self.etg(\"html\")\n        return \"\".join(self.src)\n# ---------------------------------------------------------------------\n# TWSControl ‚Äî –ø—Ä–∏—ë–º–Ω–∏–∫ WebSocket-–ø–æ—Ç–æ–∫–∞ (—É—Ä–æ–≤–µ–Ω—å —Å–≤—è–∑–∏)\n# ---------------------------------------------------------------------\nclass TWSControl(TControl):\n    def __init__(self, Owner=None, Name=\"wsControl\", Parent=None, url=\"ws://localhost:8081\", channel=\"SYS\"):\n        super().__init__(Owner, Name, Parent)\n        self.url = url\n        self.channel = channel  # ‚Üê —Ä–∞–¥–∏–æ-—á–∞—Å—Ç–æ—Ç–∞ (–∫–∞–Ω–∞–ª)\n        self.log(\"__init__\", f\"receiver {self.Name} tuned to channel '{self.channel}'\")\n\n    def html(self):\n        eid = self.id()\n        return f\"\"\"\n<script>\nconst proto = (location.protocol === 'https:') ? 'wss' : 'ws';\nconst ws = new WebSocket('{self.url}');\nconst eid = '{eid}';\nconst channel = '{self.channel}';\n\nws.onopen = () => {{\n  ws.send(JSON.stringify({{ type: \"subscribe\", channel }}));\n  console.log(`üì° Subscribed to ${{channel}}`);\n}};\n\nws.onmessage = (e) => {{\n  try {{\n    const msg = JSON.parse(e.data);\n    if (msg.channel && msg.channel !== channel) return; // —Ñ–∏–ª—å—Ç—Ä –ø–æ –∫–∞–Ω–∞–ª—É\n    const el = document.getElementById(eid);\n    if (el) {{\n      el.textContent += (msg.text || e.data) + \"\\\\n\";\n      el.scrollTop = el.scrollHeight;\n    }}\n  }} catch(err) {{\n    console.error('[WS parse error]', err);\n  }}\n}};\n</script>\n\"\"\"\n# ---------------------------------------------------------------------\n# TMonitor ‚Äî –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∫–∏–Ω–µ—Å–∫–æ–ø Tradition Core\n# ---------------------------------------------------------------------\nclass TMonitor(TWSControl):\n    def __init__(self, Owner=None, Name=\"Monitor\", Parent=None, port=8081, channel=\"SYS\"):\n        url = f\"ws://localhost:{port}\"\n        super().__init__(Owner, Name, Parent, url=url, channel=channel)\n        self.log(\"__init__\", f\"monitor {self.Name} created for {self.channel}\")\n\n    def html(self):\n        eid = self.id()\n        return f\"\"\"\n<div id=\"{eid}\" style=\"font-family:monospace;color:#00ff88;\nbackground:#1a1d29;padding:10px;border-radius:8px;\nheight:70vh;overflow-y:auto;\">Connecting to {self.channel}...</div>\n{super().html()}\n\"\"\"\n# =====================================================================\n# bb_controls.py üúÇ The End ‚Äî See You Next Session 2025 ‚öôÔ∏è\n# =====================================================================\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "bb_db.py",
      "dir": "/core",
      "lines": 770,
      "bytes": 31991,
      "updated": "2025-10-18T12:55:54Z",
      "content": "# ============================== CANONICAL ==============================\n# bb_db.py ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–∞–±–æ—á–∏–π —Ñ–∞–π–ª –ë–î (–ø—É—Å—Ç–æ–π —à–∞–±–ª–æ–Ω)\n# –ù–∏—á–µ–≥–æ –Ω–µ –º–µ–Ω—è—é –±–µ–∑ —Ç–≤–æ–µ–π –∫–æ–º–∞–Ω–¥—ã. –ú–æ–∂–µ—à—å –≤—Å—Ç–∞–≤–ª—è—Ç—å —Å–≤–æ–π —Ä–∞–±–æ—á–∏–π –∫–æ–¥.\n# ======================================================================\n\n# bb_db.py\n# ALIAS: BB_DB\n# Created: 2025-09-18\n# VERSION: QR\n# Updated: 2025-10-07 08:00:00 (MSK)\n# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∫–ª–∞—Å—Å DB —Å –∞–≤—Ç–æ-–ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º\n\nimport hashlib\nfrom datetime import datetime\n\nfrom typing import Union, Any, Dict, List, Tuple, Optional, Sequence\nfrom bb_sys import *\nfrom mysql.connector import pooling  # NEW POOL LOGIC\nimport time\nimport threading\nfrom bb_logger import init_log_router, LOG_ROUTER\n\n# === Canonical field name constants (curated, common only) ===\n\nTBL_CONFIG      = 'ZZ$CONFIG'\n\nFLD_ID          = 'FLD$ID'\nFLD_HASH        = 'FLD$HASH'\nFLD_TCOD        = 'FLD$TCOD'\nFLD_SYMBOL      = 'FLD$SYMBOL'\nFLD_TYPE        = 'FLD$TYPE'\nFLD_NAME        = 'FLD$NAME'\nFLD_TEXT        = 'FLD$TEXT'\n\nFLD_DATE        = 'FLD$DATE'\nFLD_DATE_TIME   = 'FLD$DATE_TIME'\n\nFLD_PRICE       = 'FLD$PRICE'\nFLD_VOLUME      = 'FLD$VOLUME'\nFLD_SUM         = 'FLD$SUM'\nFLD_VALUE       = 'FLD$VALUE'\n\nFLD_SOURCE      = 'FLD$SOURCE'\nFLD_URL         = 'FLD$URL'\nFLD_TITLE       = 'FLD$TITLE'\nFLD_TAGS        = 'FLD$TAGS'\nFLD_VERSION     = 'FLD$VERSION'\n\n\n# Public export surface (for `from bb_db import *`)\n__all__ = [\n    # --- core ---\n    'TDatabase', 'Application', 'CloseApplication',\n    # legacy\n    # --- QR facade ---\n    'qr', 'qr_rw',\n    'qr_add', 'qr_update', 'qr_delete',\n    'qr_foi', 'qr_fou', 'qr_max', 'exec',\n    # --- hash helpers ---\n    'mk_hash', 'mk_row_hash', 'mk_tcod',\n    # --- common fields ---\n    'FLD_ID', 'FLD_TYPE', 'FLD_HASH', 'FLD_TCOD',\n    'FLD_SYMBOL', 'FLD_SOURCE', 'FLD_URL', 'FLD_TITLE',\n    'FLD_TAGS', 'FLD_DATE', 'FLD_DATE_TIME',\n    'FLD_PRICE', 'FLD_VOLUME', 'FLD_SUM', 'FLD_VERSION',\n    'FLD_NAME', 'FLD_TEXT', 'FLD_VALUE',\n    # --- environment & system ---\n    'MSK',\n    'key', 'key_int', 'key_float', 'key_bool',\n]\n\n# --- TCOD helper -------------------------------------------------------\n# –§–æ—Ä–º–∞—Ç: SYMBOL_YYYYMMDD_HHMMSS_TF_VENUE (–≤ –ú–°–ö)\n# –ü—Ä–∏–º–µ—Ä: AIAUSDT_20250929_061600_1SEC_BYBIT\n\ndef _to_dt_msk(ts) -> datetime:\n    \"\"\"\n    –ü—Ä–∏–≤–æ–¥–∏—Ç ts –∫ timezone-aware datetime –≤ –ú–°–ö.\n    –î–æ–ø—É—Å–∫–∞–µ—Ç: epoch seconds/ms (int/float) –∏–ª–∏ datetime (naive/aware).\n    Naive datetime —Ç—Ä–∞–∫—Ç—É–µ–º –∫–∞–∫ —É–∂–µ-–ú–°–ö.\n    \"\"\"\n    if isinstance(ts, (int, float)):\n        # –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥ (–≥—Ä—É–±–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞)\n        if ts > 10**12:\n            ts = ts / 1000.0\n        return datetime.fromtimestamp(ts, tz=MSK)\n    if isinstance(ts, datetime):\n        if ts.tzinfo is None:\n            return ts.replace(tzinfo=MSK)\n        return ts.astimezone(MSK)\n    raise TypeError(f\"Unsupported ts type for mk_tcod(): {type(ts)}\")\n\ndef mk_tcod(symbol: str, ts: Union[int, float], tf: str, venue: str = \"BYBIT\") -> str:\n    \"\"\"\n    –§–æ—Ä–º–∞—Ç:\n      SYMBOL_YYYYMMDD_HHMMSS[_mmm]_TF_VENUE\n\n    - ts: UNIX-–≤—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö –ò–õ–ò –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö (–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏).\n    - –ï—Å–ª–∏ –≤ ts –µ—Å—Ç—å –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã, –¥–æ–±–∞–≤–ª—è–µ–º *_mmm* –¥–ª—è –õ–Æ–ë–û–ì–û TF (—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ).\n    \"\"\"\n    tfu = str(tf).upper()\n    vu  = str(venue).upper()\n\n    t_int = int(ts)\n    # —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: >= 1e12 ‚Üí –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã\n    is_ms = t_int >= 1_000_000_000_000\n    if is_ms:\n        sec = t_int // 1000\n        ms  = t_int % 1000\n    else:\n        sec = t_int\n        ms  = 0\n\n    dt_msk = datetime.fromtimestamp(sec, tz=MSK)\n    base = f\"{symbol}_{dt_msk.strftime('%Y%m%d_%H%M%S')}\"\n    if ms:\n        base += f\"_{ms:03d}\"\n    return f\"{base}_{tfu}_{vu}\"\n\n# --- –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π (–±—ã–≤—à–∏–π bbDBManager) ------------------------\n\nclass TSession(TSysComponent):\n    \"\"\"–ü—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π MySQL.\"\"\"\n\n    def __init__(self, Owner: \"TApplication\"):\n        super().__init__(Owner, 'Session')\n        self.cfg = DB_CFG\n        self.pool = None\n        self._keep_alive = False\n        self._keep_thread = None\n\n        # —Å—Å—ã–ª–∫–∞ –≤ Application\n        Owner.Session = self\n\n        self.log('__init__', 'session created')\n\n\n    # --- Lifecycle ---------------------------------------------------\n    def do_open(self, pool_size: int = 8) -> bool:\n        \"\"\"–°–æ–∑–¥–∞—ë—Ç –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç keep-alive.\"\"\"\n        if self.pool is not None:\n            self.log('do_open', 'pool already active')\n            return True\n\n        #x = 42 / 0\n\n\n        try:\n            self.pool = pooling.MySQLConnectionPool(\n                pool_name=\"bb_pool\",\n                pool_size=pool_size,\n                pool_reset_session=True,\n                **self.cfg\n            )\n            self.log('do_open', f'pool started (size={pool_size})')\n            self.keep_alive(60)\n            return True\n        except Exception as e:\n            self.fail('do_open', f'failed: {e}', e)\n            return False\n\n    def do_close(self) -> bool:\n        \"\"\"–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç keep-alive –∏ —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π.\"\"\"\n        if not self.pool:\n            self.log('do_close', 'no pool to stop')\n            return True\n\n        try:\n            self.stop_keep_alive()\n            self.pool = None\n            self.log('do_close', 'pool stopped')\n            return True\n        except Exception as e:\n            self.fail('do_close', f'failed: {e}', e)\n            return False\n\n    # --- Connection management --------------------------------------\n    def _get_connection(self):\n        if not self.pool:\n            raise RuntimeError(\"Session pool not initialized, call open() first\")\n        return self.pool.get_connection()\n\n    def exec(self, sql: str, params=None) -> int:\n        _, rowcount, _ = self._exec_cursor(sql, params, fetch=False)\n        return rowcount\n\n    # --- Cursor execution -------------------------------------------\n    def _exec_cursor(self, sql: str, params=None, fetch=True):\n        connection = self._get_connection()\n        cursor = None\n        try:\n            cursor = connection.cursor(buffered=True)\n            cursor.execute(sql, params or [])\n            rows = cursor.fetchall() if fetch and cursor.with_rows else []\n            return rows, cursor.rowcount, getattr(cursor, \"lastrowid\", 0)\n        finally:\n            try:\n                if cursor:\n                    cursor.close()\n                connection.close()\n            except Exception:\n                pass\n\n    # --- Keep Alive -------------------------------------------------\n    def keep_alive(self, interval: int = 60):\n        \"\"\"–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø–∏–Ω–≥—É–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Ç–∞–π–º–∞—É—Ç–∞.\"\"\"\n        if not self.pool:\n            self.log('keep_alive', 'no pool')\n            return\n\n        def _loop():\n            while getattr(self, \"_keep_alive\", False):\n                try:\n                    connection = self.pool.get_connection()\n                    connection.ping(reconnect=True, attempts=1, delay=0)\n                    connection.close()\n                    now = datetime.now().strftime(\"%H:%M:%S\")\n                    print(f\"[Session] keep_alive ping ok ({now})\")\n                except Exception as e:\n                    print(f\"[Session] keep_alive warn: {e}\")\n                time.sleep(interval)\n            print(\"[Session] keep_alive stopped\")\n\n        if getattr(self, \"_keep_alive\", False):\n            return\n\n        self._keep_alive = True\n        self._keep_thread = threading.Thread(target=_loop, daemon=True)\n        self._keep_thread.start()\n        self.log('keep_alive', f'started (interval={interval}s)')\n\n    def stop_keep_alive(self):\n        if getattr(self, \"_keep_alive\", False):\n            self._keep_alive = False\n            if hasattr(self, \"_keep_thread\"):\n                self._keep_thread.join(timeout=5)\n            self.log('keep_alive', 'stopped')\n\n# ---------------------------------------------------------------------\n#  TDatabase ‚Äî –≥–ª–∞–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Ä–∞–±–æ—Ç—ã —Å SQL –∏ —Å—Ö–µ–º–æ–π (Tradition 2025)\n# ---------------------------------------------------------------------\n\nclass TDatabase(TSysComponent):\n    \"\"\"–ì–ª–∞–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Ä–∞–±–æ—Ç—ã —Å SQL.\"\"\"\n\n    def __init__(self, Owner: \"TApplication\"):\n        if not isinstance(Owner, TApplication):\n            raise TypeError(\"TDatabase owner must be TApplication\")\n\n        super().__init__(Owner, \"Database\")\n\n        self.cfg = DB_CFG\n        self.Session = Owner.Session\n        self.Schema = Owner.Schema   # ‚Üê –ø—Ä–æ—Å—Ç–æ —Å—Å—ã–ª–∫–∞\n\n        self.log(\"__init__\", \"database initialized (linked to Schema)\")\n\n\n    # -------------------------------------------------------------\n    # Lifecycle\n    # -------------------------------------------------------------\n    def do_open(self) -> bool:\n        \"\"\"–ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –∏ –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Ç–µ—Å—Ç-–∑–∞–ø—Ä–æ—Å.\"\"\"\n        if not self.Session:\n            self.fail(\"do_open\", \"no Session assigned\", ValueError)\n            return False\n\n        # –°–µ—Å—Å–∏—è –æ–±—è–∑–∞–Ω–∞ –±—ã—Ç—å –∞–∫—Ç–∏–≤–Ω–∞\n        if not self.Session.pool:\n            self.Session.open()\n\n        try:\n            conn = self.Session._get_connection()\n            cur = conn.cursor()\n            cur.execute(\"SELECT 1\")\n            cur.fetchall()\n            cur.close()\n            conn.close()\n            self.log(\"do_open\", \"connection test passed\")\n            return True\n        except Exception as e:\n            self.fail(\"do_open\", f\"connection failed: {e}\", type(e))\n            return False\n\n    def do_close(self) -> bool:\n        \"\"\"–ó–∞–∫—Ä—ã–≤–∞–µ—Ç –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π Session.\"\"\"\n        if self.Session:\n            try:\n                self.Session.close()\n                self.log(\"do_close\", \"database connection closed\")\n                return True\n            except Exception as e:\n                self.fail(\"do_close\", f\"failed: {e}\", type(e))\n                return False\n        return True\n\n    # -------------------------------------------------------------\n    # Connections\n    # -------------------------------------------------------------\n    def _get_connection(self):\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç connection –∏–∑ –ø—É–ª–∞ Session.\"\"\"\n        return self.Session._get_connection()\n\n    # -------------------------------------------------------------\n    # Cursor execution\n    # -------------------------------------------------------------\n    def _exec_cursor(self, sql: str, params=None, fetch: bool = True):\n        \"\"\"–í—ã–ø–æ–ª–Ω—è–µ—Ç SQL –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (rows, rowcount, last_id).\"\"\"\n        link = self._get_connection()\n        query = None\n        try:\n            query = link.cursor(buffered=True)\n            query.execute(sql, params or [])\n            rows = query.fetchall() if fetch and query.with_rows else []\n            return rows, query.rowcount, getattr(query, \"lastrowid\", 0)\n        finally:\n            try:\n                if query:\n                    query.close()\n                link.close()\n            except Exception:\n                pass\n\n    def _exec_cursor_dict(self, sql: str, params=None, fetch: bool = True):\n        \"\"\"–¢–æ –∂–µ —Å–∞–º–æ–µ, –Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç dict-—Å—Ç—Ä–æ–∫–∏.\"\"\"\n        link = self._get_connection()\n        query = None\n        try:\n            query = link.cursor(buffered=True, dictionary=True)\n            query.execute(sql, params or [])\n            rows = query.fetchall() if fetch and query.with_rows else []\n            return rows, query.rowcount, getattr(query, \"lastrowid\", 0)\n        finally:\n            try:\n                if query:\n                    query.close()\n                link.close()\n            except Exception:\n                pass\n\n    # -------------------------------------------------------------\n    # WHERE builder\n    # -------------------------------------------------------------\n    @staticmethod\n    def _where_sql(where: Any) -> Tuple[str, Tuple]:\n        if where is None:\n            return \"\", ()\n        if isinstance(where, int):\n            return f\"`{FLD_ID}`=%s\", (int(where),)\n        if isinstance(where, str):\n            w = where.strip()\n            return (w[6:].strip(), ()) if w.upper().startswith(\"WHERE \") else (w, ())\n        if isinstance(where, dict):\n            parts, vals = [], []\n            for k, v in where.items():\n                col = f\"`{k}`\"\n                if v is None:\n                    parts.append(f\"{col} IS NULL\")\n                elif isinstance(v, (list, tuple, set)):\n                    vv = list(v)\n                    if not vv:\n                        parts.append(\"1=0\")\n                    else:\n                        placeholders = \", \".join([\"%s\"] * len(vv))\n                        parts.append(f\"{col} IN ({placeholders})\")\n                        vals.extend(vv)\n                else:\n                    parts.append(f\"{col}=%s\")\n                    vals.append(v)\n            return \" AND \".join(parts), tuple(vals)\n        raise TypeError(f\"Unsupported where type: {type(where)}\")\n    # -------------------------------------------------------------\n    # CRUD methods\n    # -------------------------------------------------------------\n    def exec(self, sql: str, params: Optional[Tuple] = None) -> int:\n        _, rowcount, _ = self._exec_cursor(sql, params)\n        return rowcount\n\n    def qr(self, table_or_sql: str | None = None, where=None, data: dict | None = None):\n        if table_or_sql is None:\n            rows, _, _ = self._exec_cursor_dict('SHOW TABLES', None, True)\n            return rows\n\n        s = table_or_sql.strip()\n        if (' ' in s) or s.upper().startswith(('SELECT', 'SHOW', 'DESC', 'EXPLAIN')):\n            rows, _, _ = self._exec_cursor_dict(s, tuple(where or ()), True)\n            return rows\n\n        fields = (data or {}).get('fields', '*')\n        order_by = (data or {}).get('order_by')\n        limit = (data or {}).get('limit')\n        wsql, wparams = self._where_sql(where)\n        sql = f'SELECT {fields} FROM `{table_or_sql}`'\n        if wsql:\n            sql += f' WHERE {wsql}'\n        if order_by:\n            sql += f' ORDER BY {order_by}'\n        if isinstance(limit, int) and limit > 0:\n            sql += f' LIMIT {limit}'\n        rows, _, _ = self._exec_cursor_dict(sql, wparams, True)\n        return rows\n\n    def qr_rw(self, table_or_sql: str | None = None, where=None, data: dict | None = None):\n        fields = data.pop('fields') if data and 'fields' in data else '*'\n        rows = self.qr(table_or_sql, where, {'fields': fields})\n        return rows[0] if rows else None\n\n    def qr_add(self, table_name: str, data: Dict[str, Any]) -> dict:\n        if not isinstance(data, dict) or not data:\n            raise ValueError('qr_add: data must be non-empty dict')\n        cols = list(data.keys())\n        vals = [data[k] for k in cols]\n        cols_sql = ', '.join(f'`{c}`' for c in cols)\n        placeholders = ', '.join(['%s'] * len(vals))\n        sql = f'INSERT INTO `{table_name}` ({cols_sql}) VALUES ({placeholders})'\n        _, _, lastrowid = self._exec_cursor(sql, tuple(vals), fetch=False)\n        if not lastrowid:\n            return {}\n        return self.qr_rw(table_name, {FLD_ID: int(lastrowid)}) or {}\n\n    def qr_update(self, table_name: str, where: Dict[str, Any], data: Dict[str, Any]) -> dict:\n        if not where or not data:\n            raise ValueError('qr_update: both WHERE and DATA required')\n        set_sql = ', '.join(f'`{k}`=%s' for k in data.keys())\n        wsql, wparams = self._where_sql(where)\n        sql = f'UPDATE `{table_name}` SET {set_sql} WHERE {wsql}'\n        params = list(data.values()) + list(wparams)\n        self._exec_cursor(sql, tuple(params), fetch=False)\n        return self.qr_rw(table_name, where) or {}\n\n    def qr_delete(self, table_name: str, where: Dict[str, Any]) -> dict:\n        row = self.qr_rw(table_name, where)\n        if not row:\n            return {}\n        wsql, wparams = self._where_sql(where)\n        sql = f'DELETE FROM `{table_name}` WHERE {wsql}'\n        self._exec_cursor(sql, tuple(wparams), fetch=False)\n        return row\n\n    def qr_foi(self, table_name: str, where: dict, data: dict) -> dict:\n        row = self.qr_rw(table_name, where)\n        return row if row else self.qr_add(table_name, {**where, **data})\n\n    def qr_fou(self, table_name: str, where: dict, data: dict) -> dict:\n        row = self.qr_rw(table_name, where)\n        if row:\n            result = self.qr_update(table_name, where, data)\n            return result or self.qr_rw(table_name, where) or {}\n        return self.qr_add(table_name, {**where, **data})\n\n    def qr_max(self, table_name: str, field_name: str, where=None):\n        row = self.qr_rw(table_name, where, {'fields': f'MAX(`{field_name}`) AS m', 'limit': 1})\n        return row.get('m') if row and row.get('m') is not None else None\n\n    # -------------------------------------------------------------\n    # HASH helpers\n    # -------------------------------------------------------------\n    def mk_hash(self, *parts: Any) -> str:\n        base = \"|\".join([(str(p if p is not None else \"\").strip()) for p in parts])\n        return hashlib.md5(base.encode(\"utf-8\")).hexdigest()\n\n    def mk_row_hash(self, row: Dict[str, Any], fields: Sequence[str]) -> str:\n        values = [str(row.get(f, \"\") if row.get(f, \"\") is not None else \"\").strip() for f in fields]\n        return hashlib.md5(\"|\".join(values).encode(\"utf-8\")).hexdigest()\n\n\nclass TConfig(TSysComponent):\n    \"\"\"–ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞ ‚Äî —É–ø—Ä–∞–≤–ª—è–µ—Ç ENV –∏ —Ç–∞–±–ª–∏—Ü–µ–π ZZ$CONFIG.\"\"\"\n\n    def __init__(self, Owner: \"TApplication\"):\n        if not isinstance(Owner, TApplication):\n            raise TypeError(\"TConfig owner must be TApplication\")\n\n        super().__init__(Owner, 'Config')\n        self.table = TBL_CONFIG\n        self.env: dict[str, str] = {}\n\n        # —Å—Å—ã–ª–∫–∞ –≤ Application\n        Owner.Config = self\n        self.log('__init__', 'config initialized')\n\n    # ================================================================\n    # === –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è (ENV + DB)\n    # ================================================================\n    def do_set(self, name: str, value: str, text: str = '', type_: str = 'AUTO') -> dict:\n        \"\"\"–ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø–∏—Å–∏ –∑–Ω–∞—á–µ–Ω–∏—è –≤ ENV –∏ —Ç–∞–±–ª–∏—Ü—É –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.\"\"\"\n        if not name:\n            self.fail('do_set', 'name required', ValueError)\n            return {}\n\n        self.env[name] = str(value)\n        record = {\n            FLD_NAME: name,\n            FLD_VALUE: str(value),\n            FLD_TYPE: type_,\n            FLD_TEXT: text or '',\n        }\n\n        try:\n            from bb_db import qr_fou\n            r = qr_fou(self.table, {FLD_NAME: name}, record)\n            self.log('do_set', f'{name}={value}')\n            return r\n        except Exception as e:\n            self.fail('do_set', f'error: {e}', e)\n            return {}\n\n    # ================================================================\n    # === –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–æ—Å—Ç—É–ø–∞\n    # ================================================================\n    def get(self, name: str, default: str = '') -> str:\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ (ENV –∏–ª–∏ default, –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ ‚Äî –¥–æ–±–∞–≤–ª—è–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü—É).\"\"\"\n        if not name:\n            return ''\n\n        val = self.env.get(name)\n        if val is not None:\n            return val\n\n        # –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –µ–≥–æ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —á–µ—Ä–µ–∑ do_set()\n        self.do_set(name, default, text='auto-created by get()')\n        return str(default)\n\n    def set(self, name: str, value: str, text: str = None, type_: str = None) -> dict:\n        \"\"\"–ü—É–±–ª–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è.\"\"\"\n        return self.do_set(name, value, text=text or '', type_=type_ or 'MANUAL')\n\n    # ================================================================\n    # === –¢–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≥–µ—Ç—Ç–µ—Ä—ã\n    # ================================================================\n    def get_int(self, name: str, default: int = 0) -> int:\n        try:\n            return int(self.get(name, default))\n        except Exception:\n            self.do_set(name, default)\n            return int(default)\n\n    def get_float(self, name: str, default: float = 0.0) -> float:\n        try:\n            return float(self.get(name, default))\n        except Exception:\n            self.do_set(name, default)\n            return float(default)\n\n    def get_bool(self, name: str, default: bool = False) -> bool:\n        v = str(self.get(name, str(int(default)))).strip().lower()\n        if v in ('', '0', 'false', 'off', 'none', 'null'):\n            return False\n        try:\n            return bool(int(v))\n        except Exception:\n            return True\n\n# ---------------------------------------------------------------------\n#  TSchema ‚Äî –ø–æ–¥—Å–∏—Å—Ç–µ–º–∞ –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ë–î (Stage 1 / PPS Doctrine)\n# ---------------------------------------------------------------------\n\nclass TSchema(TSysComponent):\n    \"\"\"–°–∏—Å—Ç–µ–º–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç: —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–∞–±–ª–∏—Ü, introspection, constants.\"\"\"\n\n    def __init__(self, Owner: \"TApplication\"):\n        if not isinstance(Owner, TApplication):\n            raise TypeError(\"TSchema owner must be TApplication\")\n        super().__init__(Owner, \"Schema\")\n        self.tables: dict[str, dict] = {}\n        # –¥–æ–±–∞–≤–ª–µ–Ω–æ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –∏ —Å—Ç–µ–π—Ç–æ–≤:\n        self.fields: dict[str, dict] = {}\n        self.indices: dict[str, dict] = {}\n        self.constants: dict[str, Any] = {}\n        self.initialized: bool = False\n        self.last_loaded: Optional[datetime] = None\n        Owner.Schema = self\n\n        self.log(\"__init__\", \"schema component created\")\n\n\n    # -------------------------------------------------------------\n    # Lifecycle\n    # -------------------------------------------------------------\n    def do_open(self) -> bool:\n\n        self.allow_prefixes = explode(';', key(\"SCHEMA_ALLOW_PREFIXES\", \"TBL$,DOC$,REF$,SYS$\"))\n        self.allow_names    = explode(';', key(\"SCHEMA_ALLOW_NAMES\", \"\"))\n        self.deny_prefixes  = explode(';', key(\"SCHEMA_DENY_PREFIXES\", \"TMP$,ARCH$,DEV$\"))\n        self.deny_names     = explode(';', key(\"SCHEMA_DENY_NAMES\", \"\"))\n\n        # === 2. –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∞–±–ª–∏—Ü ===\n        self._load_tables()\n        self.log('do_open', f'schema loaded: {len(self.tables)} tables')\n\n        return True\n\n    def do_close(self) -> bool:\n        \"\"\"–û—á–∏—â–∞–µ—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ.\"\"\"\n        self.tables.clear()\n        self.fields.clear()\n        self.indices.clear()\n        self.constants.clear()\n        self.initialized = False\n        self.last_loaded = None\n        self.log(\"do_close\", \"schema cleared\")\n        return True\n\n    # -------------------------------------------------------------\n    # –ó–∞–≥–ª—É—à–∫–∏ –ø–æ–¥ –±—É–¥—É—â—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é (Stage 2)\n    # -------------------------------------------------------------\n    # ==========================================================\n    def _load_tables(self) -> dict[str, dict]:\n        \"\"\"–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü –∏–∑ –±–∞–∑—ã, —Ñ–∏–ª—å—Ç—Ä—É–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ self.tables.\"\"\"\n        from bb_db import qr\n\n        # --- –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã ---\n        rows = qr(\"SHOW TABLES\")\n        all_tables = [list(row.values())[0] for row in rows]\n        self.log('_load_tables', f'scanned {len(all_tables)} tables')\n\n        # --- –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ allow/deny ---\n        filtered = []\n        for t in all_tables:\n            tn = t.upper()\n            if any(tn.startswith(p) for p in self.deny_prefixes):\n                continue\n            if tn in self.deny_names:\n                continue\n            if self.allow_prefixes and not any(tn.startswith(p) for p in self.allow_prefixes):\n                continue\n            if self.allow_names and tn not in self.allow_names:\n                continue\n            filtered.append(t)\n\n        # --- –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç ---\n        self.tables = {name: {} for name in filtered}\n        self.log('_load_tables', f'allowed {len(filtered)} of {len(all_tables)}')\n        return self.tables\n\n    def _register_constants(self):\n        \"\"\"–§–æ—Ä–º–∏—Ä—É–µ—Ç –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã.\"\"\"\n        # placeholder ‚Äî –ø–æ–∑–∂–µ –¥–æ–±–∞–≤–∏—Ç—Å—è builtins.setattr()\n        self.log(\"_register_constants\", \"stage 1 stub (const builder)\")\n\n# --- Application ---\n\ndef Application() -> TApplication:\n    \"\"\"–°–æ–∑–¥–∞—ë—Ç –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Tradition Framework.\"\"\"\n    init_log_router()\n    if LOG_ROUTER:\n        print(\"üåà [Rich] LogRouter initialized ‚Äî multi-window console active\", flush=True)\n    else:\n        print(\"ü™∂ [Fallback] Plain console logger active\", flush=True)\n\n    app = TApplication.app()\n\n    if not getattr(app, \"Database\", None):\n        # --- —Å–æ–∑–¥–∞—ë–º –æ—Å–Ω–æ–≤–Ω—ã–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ —Å—É—â–Ω–æ—Å—Ç–∏ ---\n        app.Session = TSession(app)\n        app.Database = TDatabase(app)\n        app.Config = TConfig(app)\n        app.Schema = TSchema(app)       # ‚Üê —Ç–µ–ø–µ—Ä—å Schema –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç Application\n\n        app.log(\"Application\", \"core components created (Session, Database, Config, Schema)\")\n\n        #try:\n            # === –ó–∞–∫–æ–Ω Tradition: —á–µ—Ç—ã—Ä–µ –∑–∞—Ç–≤–æ—Ä–∞ ===\n        app.Session.open()\n        app.Database.open()\n        app.Config.open()\n        app.Schema.open()\n\n        app.log(\"Application\", \"Config & Schema loaded, database connected\")\n        #except Exception as e:\n            #app.fail(\"Application\", f\"init error: {e}\")\n\n    app.log(\"Application\", \"log center initialized\", window=1)\n    return app\n\ndef CloseApplication():\n    \"\"\"–ó–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∞–±–æ—Ç—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: –∫—Ä–∞—Å–∏–≤–æ, —Å —á—É–≤—Å—Ç–≤–æ–º –∏ –Ω–µ–º–Ω–æ–≥–æ –∏—Ä–æ–Ω–∏–∏.\"\"\"\n    app = TApplication._instance\n    if app is None:\n        return\n    try:\n        if hasattr(app, \"Session\"):\n            app.Session.close()\n        if hasattr(app, \"Components\"):\n            for name in list(app.Components.keys()):\n                app.log('CloseApplication', f'releasing {name}')\n            app.Components.clear()\n        app.log('CloseApplication', 'application terminated successfully')\n    except Exception as e:\n        print(f\"[Application] close warning: {e}\")\n    finally:\n        TApplication._instance = None\n        print(\"\\nüé¨  The End ‚Äî HappyEnd edition üåÖ\\n\")\n\n# === –§–∞—Å–∞–¥–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (—Ç–æ–Ω–∫–∏–µ –æ–±—ë—Ä—Ç–∫–∏) ===\n\ndef qr_add(table: str, data: Dict[str, Any]):\n    \"\"\"–î–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ —Ç–∞–±–ª–∏—Ü—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç dict –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏.\"\"\"\n    return Application().Database.qr_add(table, data)\n\ndef qr_update(table: str, where: Any, data: Dict[str, Any]):\n    \"\"\"–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç—Ä–æ–∫–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç dict –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å).\"\"\"\n    return Application().Database.qr_update(table, where, data)\n\ndef qr_delete(table: str, where: Any, data: Optional[Dict[str, Any]] = None):\n    \"\"\"–£–¥–∞–ª—è–µ—Ç —Å—Ç—Ä–æ–∫–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö (int).\"\"\"\n    limit = None\n    if isinstance(data, dict) and isinstance(data.get(\"limit\"), int):\n        limit = data[\"limit\"]\n    return Application().Database.qr_delete(table, where)\n\ndef qr_foi(table: str, where: Any, data: Dict[str, Any]):\n    \"\"\"Find-Or-Insert ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç dict —Å—Ç—Ä–æ–∫–∏ (–≤—Å–µ–≥–¥–∞ —Å–≤–µ–∂–µ–π).\"\"\"\n    return Application().Database.qr_foi(table, where, data)\n\ndef qr_fou(table: str, where: dict, data: dict):\n    \"\"\"Find-Or-Update ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç dict —Å—Ç—Ä–æ–∫–∏.\"\"\"\n    return Application().Database.qr_fou(table, where, data)\n\ndef qr_max(table_name: str, field_name: str, where=None):\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ MAX(field_name) ‚Äî –ø—Ä–∏–º–∏—Ç–∏–≤, –Ω–µ dict.\"\"\"\n    return Application().Database.qr_max(table_name, field_name, where)\n\ndef qr(table_or_sql: str | None = None, where=None, data: dict | None = None):\n    \"\"\"–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å SELECT / SHOW.\"\"\"\n    return Application().Database.qr(table_or_sql, where, data)\n\ndef qr_rw(table_or_sql: str | None = None, where=None, data: dict | None = None):\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É (row) –ø–æ —É—Å–ª–æ–≤–∏—é WHERE.\"\"\"\n    return Application().Database.qr_rw(table_or_sql, where, data)\n\ndef exec(sql: str, params: Optional[Tuple] = None):\n    \"\"\"–í—ã–ø–æ–ª–Ω—è–µ—Ç SQL-–∑–∞–ø—Ä–æ—Å –±–µ–∑ –≤—ã–±–æ—Ä–∫–∏ (INSERT/UPDATE/DELETE).\"\"\"\n    return Application().Database.exec(sql, params)\n\n# --- HASH facade wrappers ---\n\ndef mk_hash(*parts: Any) -> str:\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç MD5-—Ö—ç—à —Å—Ç—Ä–æ–∫–∏ –∏–∑ —á–∞—Å—Ç–µ–π.\"\"\"\n    return Application().Database.mk_hash(*parts)\n\ndef mk_row_hash(row: Dict[str, Any], fields: Sequence[str]) -> str:\n    \"\"\"–•—ç—à–∏—Ä—É–µ—Ç –Ω–∞–±–æ—Ä –ø–æ–ª–µ–π —Å—Ç—Ä–æ–∫–∏ (–ø–æ –∑–Ω–∞—á–µ–Ω–∏—è–º).\"\"\"\n    return Application().Database.mk_row_hash(row, fields)\n\n# === CONFIG FACADE (COMPAT LAYER) ===\n\ndef key(name: str | None, default: str = '') -> str | None:\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ (ENV / ZZ$CONFIG).\"\"\"\n    return Application().Config.get(name, default)\n\ndef set_key(name: str, value: Any, text: str = None, type_: str = None) -> dict:\n    \"\"\"–û–±–Ω–æ–≤–ª—è–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (ENV / ZZ$CONFIG).\"\"\"\n    return Application().Config.set(name, value, text=text or '', type_=type_ or 'MANUAL')\n\ndef key_int(name: str, default: int = 0) -> int:\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–∞–∫ int.\"\"\"\n    return Application().Config.get_int(name, default)\n\ndef key_float(name: str, default: float = 0.0) -> float:\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–∞–∫ float.\"\"\"\n    return Application().Config.get_float(name, default)\n\ndef key_bool(name: str, default: bool = False) -> bool:\n    \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–∞–∫ bool.\"\"\"\n    return Application().Config.get_bool(name, default)\n# =====================================================================\n# bb_db.py üúÇ The End ‚Äî See You Next Session 2025 ‚öôÔ∏è  768\n# =====================================================================\n"
    },
    {
      "name": "bb_events.py",
      "dir": "/core",
      "lines": 296,
      "bytes": 11044,
      "updated": "2025-10-18T12:55:54Z",
      "content": "# bb_events.py\n# ALIAS: BB_EVENTS\n# Created: 2025-10-18 07:26\n# –°—Ö–µ–º–∞ —Å–æ–±—ã—Ç–∏–π –∏ —Å–∏—Å—Ç–µ–º–∞ –ø–æ–¥–ø–∏—Å–æ–∫ Tradition Core 2025\nimport time\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional\nfrom dataclasses import dataclass\nfrom pydantic import BaseModel\nimport json\n# ---------------------------------------------------------------------\n# –¢–∏–ø—ã —Å–æ–±—ã—Ç–∏–π\n# ---------------------------------------------------------------------\nclass TEventType(str, Enum):\n    TICK = \"tick\"\n    STATUS = \"status\"\n    LOG = \"log\"\n    COMMAND = \"command\"\n    UI = \"ui\"\n    SYSTEM = \"system\"\n# ---------------------------------------------------------------------\n# –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ö–µ–º–∞ —Å–æ–±—ã—Ç–∏—è\n# ---------------------------------------------------------------------\nclass TEvent(BaseModel):\n    type: TEventType\n    source: str\n    topic: str\n    timestamp: float\n    payload: Dict[str, Any]\n\n    @classmethod\n    def create(cls,\n               event_type: TEventType,\n               source: str,\n               topic: str,\n               payload: Dict[str, Any]) -> 'TEvent':\n        return cls(\n            type=event_type,\n            source=source,\n            topic=topic,\n            timestamp=time.time(),\n            payload=payload\n        )\n\n    def to_json(self) -> str:\n        return self.json()\n\n    @classmethod\n    def from_json(cls, json_str: str) -> Optional['TEvent']:\n        try:\n            data = json.loads(json_str)\n            return cls(**data)\n        except:\n            return None\n# ---------------------------------------------------------------------\n# –ü–æ–¥–ø–∏—Å–∫–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏–π\n# ---------------------------------------------------------------------\n@dataclass\nclass TSubscription:\n    target_id: str  # id –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞-–ø–æ–ª—É—á–∞—Ç–µ–ª—è\n    topic: str  # —Ç–µ–º–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏\n    filters: Dict[str, Any]  # —É—Å–ª–æ–≤–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏\n\n    def matches(self, event: TEvent) -> bool:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ —Å–æ–±—ã—Ç–∏–µ –ø–æ–¥–ø–∏—Å–∫–µ\"\"\"\n        if self.topic != event.topic:\n            return False\n\n        for key, expected_value in self.filters.items():\n            actual_value = event.payload.get(key)\n            if actual_value != expected_value:\n                return False\n\n        return True\n# ---------------------------------------------------------------------\n# –ö–∞–Ω–∞–ª—ã WebSocket –¥–∞–Ω–Ω—ã—Ö (–Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–µ –ø–æ—Ç–æ–∫–∏)\n# ---------------------------------------------------------------------\nclass TwsDataChannel(str, Enum):\n    MARKET_TICKS = \"market.ticks\"  # –ü–æ—Ç–æ–∫ —Ç–∏–∫–æ–≤\n    MARKET_CANDLES_1S = \"market.candles.1s\"  # –°–µ–∫—É–Ω–¥–Ω—ã–µ —Å–≤–µ—á–∏\n    MARKET_CANDLES_1M = \"market.candles.1m\"  # –ú–∏–Ω—É—Ç–Ω—ã–µ —Å–≤–µ—á–∏\n    MARKET_DEPTH = \"market.depth\"  # –°—Ç–∞–∫–∞–Ω –∑–∞—è–≤–æ–∫\n    TRADES = \"market.trades\"  # –°–¥–µ–ª–∫–∏\n    SYSTEM_METRICS = \"system.metrics\"  # –ú–µ—Ç—Ä–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã\n@dataclass\nclass TwsChannelSubscription:\n    \"\"\"–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –∫–∞–Ω–∞–ª WebSocket –¥–∞–Ω–Ω—ã—Ö\"\"\"\n    target_id: str  # id –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞-–ø–æ–ª—É—á–∞—Ç–µ–ª—è\n    channel: TwsDataChannel  # –∫–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö\n    symbols: List[str]  # —Å–ø–∏—Å–æ–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤\n    filters: Dict[str, Any]  # –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã\n\n    def matches(self, data_point: \"TwsChannelData\") -> bool:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–æ—á–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–∫–µ\"\"\"\n        if self.channel != data_point.channel:\n            return False\n\n        if self.symbols and data_point.symbol not in self.symbols:\n            return False\n\n        for key, expected_value in self.filters.items():\n            actual_value = data_point.data.get(key)\n            if actual_value != expected_value:\n                return False\n\n        return True\n\nclass TwsChannelData(BaseModel):\n    \"\"\"–¢–æ—á–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ WebSocket\"\"\"\n    channel: TwsDataChannel\n    symbol: str\n    timestamp: float\n    sequence: int = 0  # –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –≤ –ø–æ—Ç–æ–∫–µ\n    data: Dict[str, Any]\n\n    @classmethod\n    def create(cls,\n               channel: TwsDataChannel,\n               symbol: str,\n               data: Dict[str, Any],\n               sequence: int = 0) -> 'TwsChannelData':\n        return cls(\n            channel=channel,\n            symbol=symbol,\n            timestamp=time.time(),\n            sequence=sequence,\n            data=data\n        )\n# ---------------------------------------------------------------------\n# –ò–Ω–¥–µ–∫—Å—ã –ø–æ–¥–ø–∏—Å–æ–∫\n# ---------------------------------------------------------------------\nclass TSubscriptionIndex:\n    def __init__(self):\n        self._subscriptions: Dict[str, List[TSubscription]] = {}\n        self._all_subscriptions: List[TSubscription] = []\n\n    def add(self, subscription: TSubscription):\n        \"\"\"–î–æ–±–∞–≤–ª—è–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –≤ –∏–Ω–¥–µ–∫—Å\"\"\"\n        topic = subscription.topic\n\n        if topic not in self._subscriptions:\n            self._subscriptions[topic] = []\n\n        self._subscriptions[topic].append(subscription)\n        self._all_subscriptions.append(subscription)\n\n    def find(self, event: TEvent) -> List[TSubscription]:\n        \"\"\"–ù–∞—Ö–æ–¥–∏—Ç –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å–æ–±—ã—Ç–∏—é\"\"\"\n        matching = []\n        topic_subs = self._subscriptions.get(event.topic, [])\n        for sub in topic_subs:\n            if sub.matches(event):\n                matching.append(sub)\n        return matching\n\n    def remove_by_target(self, target_id: str):\n        \"\"\"–£–¥–∞–ª—è–µ—Ç –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ target_id\"\"\"\n        for topic in list(self._subscriptions.keys()):\n            self._subscriptions[topic] = [\n                sub for sub in self._subscriptions[topic]\n                if sub.target_id != target_id\n            ]\n            if not self._subscriptions[topic]:\n                del self._subscriptions[topic]\n\n        self._all_subscriptions = [\n            sub for sub in self._all_subscriptions\n            if sub.target_id != target_id\n        ]\n\n    def count(self) -> int:\n        return len(self._all_subscriptions)\n\n\nclass TwsChannelSubscriptionIndex:\n    def __init__(self):\n        self._channel_subscriptions: Dict[TwsDataChannel, List[TwsChannelSubscription]] = {}\n        self._all_subscriptions: List[TwsChannelSubscription] = []\n\n    def add(self, subscription: TwsChannelSubscription):\n        \"\"\"–î–æ–±–∞–≤–ª—è–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –∫–∞–Ω–∞–ª\"\"\"\n        channel = subscription.channel\n\n        if channel not in self._channel_subscriptions:\n            self._channel_subscriptions[channel] = []\n\n        self._channel_subscriptions[channel].append(subscription)\n        self._all_subscriptions.append(subscription)\n\n    def find(self, data_point: TwsChannelData) -> List[TwsChannelSubscription]:\n        \"\"\"–ù–∞—Ö–æ–¥–∏—Ç –ø–æ–¥–ø–∏—Å–∫–∏, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç–æ—á–∫–µ –¥–∞–Ω–Ω—ã—Ö\"\"\"\n        matching = []\n        channel_subs = self._channel_subscriptions.get(data_point.channel, [])\n        for sub in channel_subs:\n            if sub.matches(data_point):\n                matching.append(sub)\n        return matching\n\n    def remove_by_target(self, target_id: str):\n        \"\"\"–£–¥–∞–ª—è–µ—Ç –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –∫–∞–Ω–∞–ª–∞ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ target_id\"\"\"\n        for channel in list(self._channel_subscriptions.keys()):\n            self._channel_subscriptions[channel] = [\n                sub for sub in self._channel_subscriptions[channel]\n                if sub.target_id != target_id\n            ]\n            if not self._channel_subscriptions[channel]:\n                del self._channel_subscriptions[channel]\n\n        self._all_subscriptions = [\n            sub for sub in self._all_subscriptions\n            if sub.target_id != target_id\n        ]\n\n    def count(self) -> int:\n        return len(self._all_subscriptions)\n# ---------------------------------------------------------------------\n# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö\n# ---------------------------------------------------------------------\ndef create_tick_event(source: str, symbol: str, price: float, volume: float = 0) -> TEvent:\n    return TEvent.create(\n        event_type=TEventType.TICK,\n        source=source,\n        topic=\"market.ticks\",\n        payload={\n            \"exchange\": source,\n            \"symbol\": symbol,\n            \"price\": price,\n            \"volume\": volume\n        }\n    )\n\ndef create_status_event(source: str, status: str, message: str = \"\") -> TEvent:\n    return TEvent.create(\n        event_type=TEventType.STATUS,\n        source=source,\n        topic=\"system.status\",\n        payload={\n            \"component\": source,\n            \"status\": status,\n            \"message\": message,\n            \"ts\": time.time()\n        }\n    )\n\ndef create_ui_command(source: str, target: str, action: str, data: Dict = None) -> TEvent:\n    return TEvent.create(\n        event_type=TEventType.COMMAND,\n        source=source,\n        topic=\"ui.command\",\n        payload={\n            \"target\": target,\n            \"action\": action,\n            \"data\": data or {},\n            \"user\": source\n        }\n    )\n\ndef create_tick_channel_data(source: str, symbol: str, price: float, volume: float = 0) -> TwsChannelData:\n    return TwsChannelData.create(\n        channel=TwsDataChannel.MARKET_TICKS,\n        symbol=symbol,\n        data={\n            \"exchange\": source,\n            \"price\": price,\n            \"volume\": volume,\n            \"bid\": price * 0.999,\n            \"ask\": price * 1.001\n        }\n    )\n\ndef create_candle_channel_data(symbol: str, open_price: float, high: float, low: float,\n                               close: float, volume: float, interval: str = \"1s\") -> TwsChannelData:\n    channel = TwsDataChannel.MARKET_CANDLES_1S\n    if interval == \"1m\":\n        channel = TwsDataChannel.MARKET_CANDLES_1M\n\n    return TwsChannelData.create(\n        channel=channel,\n        symbol=symbol,\n        data={\n            \"open\": open_price,\n            \"high\": high,\n            \"low\": low,\n            \"close\": close,\n            \"volume\": volume,\n            \"interval\": interval\n        }\n    )\n\n# –≠–∫—Å–ø–æ—Ä—Ç—ã\n__all__ = [\n    'TEventType', 'TEvent', 'TSubscription', 'TSubscriptionIndex',\n    'TwsDataChannel', 'TwsChannelSubscription', 'TwsChannelData', 'TwsChannelSubscriptionIndex',\n    'create_tick_event', 'create_status_event', 'create_ui_command',\n    'create_tick_channel_data', 'create_candle_channel_data'\n]"
    },
    {
      "name": "bb_logger.py",
      "dir": "/core",
      "lines": 129,
      "bytes": 4599,
      "updated": "2025-10-18T12:55:54Z",
      "content": "# bb_logger.py\n# Rich LogRouter for Delphi.2025\n# Created: 2025-10-13\n\n\nfrom rich.console import Console\nfrom rich.live import Live\nfrom rich.panel import Panel\nfrom rich.text import Text\nimport threading\nimport time\n\n\nclass TLogRouter:\n    \"\"\"–ì–ª–æ–±–∞–ª—å–Ω—ã–π Rich –ª–æ–≥-—Ü–µ–Ω—Ç—Ä —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –æ–∫–Ω–∞–º–∏.\"\"\"\n\n    def __init__(self, window_count: int = 3, refresh_rate: float = 0.5):\n        self.console = Console()\n        self.window_count = window_count\n        self.refresh_rate = refresh_rate\n        self.buffers = {i: [] for i in range(1, window_count + 1)}\n        self.lock = threading.Lock()\n        self._stop = False\n\n        # —Å–æ–∑–¥–∞—ë–º –ø–æ—Ç–æ–∫ —Ä–µ–Ω–¥–µ—Ä–∞\n        self.thread = threading.Thread(target=self._render_loop, daemon=True)\n        self.thread.start()\n\n    # ---------------------------------------------------------\n    # API\n    # ---------------------------------------------------------\n    def write(self, message: str, window: int = 1):\n        \"\"\"–î–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç—Ä–æ–∫—É –≤ –æ–∫–Ω–æ.\"\"\"\n        with self.lock:\n            buf = self.buffers.get(window, [])\n            buf.append(message)\n            if len(buf) > 200:\n                buf.pop(0)\n\n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Å–æ–ª–∏.\"\"\"\n        self._stop = True\n        self.thread.join(timeout=2)\n\n    # ---------------------------------------------------------\n    # –û—Ç—Ä–∏—Å–æ–≤–∫–∞\n    # ---------------------------------------------------------\n    def _render_loop(self):\n        \"\"\"–§–æ–Ω–æ–≤—ã–π —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è Rich Live Console.\"\"\"\n        with Live(console=self.console, refresh_per_second=int(1 / self.refresh_rate)) as live:\n            while not self._stop:\n                layout = self._layout()\n                live.update(layout)\n                time.sleep(self.refresh_rate)\n\n    def _layout(self):\n        \"\"\"–°–æ–∑–¥–∞—ë—Ç layout –∏–∑ –ø–∞–Ω–µ–ª–µ–π (–ø–æ –æ–∫–Ω–∞–º).\"\"\"\n        panels = []\n        with self.lock:\n            for i in range(1, self.window_count + 1):\n                lines = self.buffers[i]\n                text = \"\\n\".join(lines[-20:]) or \"(no logs)\"\n                panels.append(Panel(Text(text), title=f\"Log Window {i}\"))\n\n        # –æ–±—ä–µ–¥–∏–Ω—è–µ–º –ø–∞–Ω–µ–ª–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ\n        return Panel.fit(\n            Text(\"\\n\\n\".join(p.renderable.plain for p in panels)),\n            title=\"Rich Log Console\",\n        )\n\n# ---------------------------------------------------------\n# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä\n# ---------------------------------------------------------\nLOG_ROUTER: TLogRouter | None = None\n\n\ndef init_log_router():\n    global LOG_ROUTER\n    if LOG_ROUTER is None:\n        LOG_ROUTER = TLogRouter()\n    return LOG_ROUTER\n\n\n# bb_logger.py ‚Äî –¥–æ–ø–æ–ª–Ω–∏ –≤–Ω–∏–∑—É —Ñ–∞–π–ª–∞\n\nclass TLogRouterMixin:\n    \"\"\"\n    –ú–∏–∫—Å–∏–Ω –¥–ª—è –∫–ª–∞—Å—Å–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ö–æ—Ç—è—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Rich LogRouter –Ω–∞–ø—Ä—è–º—É—é.\n    –î–æ–±–∞–≤–ª—è–µ—Ç –º–µ—Ç–æ–¥ route_log() –∏ —Å–≤–æ–π—Å—Ç–≤–æ router.\n    \"\"\"\n\n    @property\n    def router(self):\n        from bb_logger import LOG_ROUTER\n        return LOG_ROUTER\n\n    def route_log(self, msg: str, window: int = 1):\n        \"\"\"–£–ø—Ä–æ—â—ë–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç—Ä–æ–∫–∏ –Ω–∞–ø—Ä—è–º—É—é –≤ –ª–æ–≥-–æ–∫–Ω–æ.\"\"\"\n        if self.router:\n            self.router.write(msg, window)\n        else:\n            print(msg, flush=True)\n\n\nclass LoggableComponent:\n    \"\"\"\n    –ë–∞–∑–æ–≤—ã–π –º–∏–∫—Å–∏–Ω, –¥–æ–±–∞–≤–ª—è—é—â–∏–π –ø–æ–¥–¥–µ—Ä–∂–∫—É —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è.\n    –í—Å–µ –ø–æ—Ç–æ–º–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç Rich LogRouter (–µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω).\n    \"\"\"\n\n    def log(self, function: str, *parts, window: int = 1):\n        from datetime import datetime\n        from bb_logger import LOG_ROUTER\n        from bb_sys import _key\n\n        project_symbol = _key('PROJECT_SYMBOL', 'BB')\n        project_version = _key('PROJECT_VERSION', '3')\n        now = datetime.now().strftime('%H:%M:%S')\n        msg = ' '.join(str(p) for p in parts)\n        text = f'[{project_symbol}_{project_version}][{now}][{self.__class__.__name__}]{function}(): {msg}'\n\n        try:\n            if LOG_ROUTER:\n                LOG_ROUTER.write(text, window=window)\n            else:\n                print(text, flush=True)\n        except Exception:\n            print(text, flush=True)\n"
    },
    {
      "name": "bb_sys.py",
      "dir": "/core",
      "lines": 1058,
      "bytes": 42438,
      "updated": "2025-10-18T12:55:54Z",
      "content": "# bb_sys.py\n# ALIAS: BB_SYS\n# Created: 2025-10-11 12:23\n# Updated: 2025-10-17 07:20 ‚Äî Tradition Core 2025:\n#  - –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø–æ–ª—è: PascalCase (Owner/Components/Modules/Pages/Name/Parent/Controls/Forms)\n#  - id() ‚Äî –≤—Å–µ–≥–¥–∞ —Å –º–∞–ª–µ–Ω—å–∫–æ–π (—Ä–æ–¥–æ—Å–ª–æ–≤–Ω–∞—è)\n#  - –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–µ—Å—Ç—Ä –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (feature-flag)\n#  - –ò–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–µ—Ä–µ–≤–∞ –∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ —Ä–µ–µ—Å—Ç—Ä–∞\n#  - –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –∏–º–µ–Ω–∞–º–∏ —á–µ—Ä–µ–∑ @property\n\nimport os\nimport re\nimport datetime as dt\nimport traceback\nimport threading\nimport asyncio\nimport json\nimport logging\nimport subprocess\n\nfrom typing import MutableMapping\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import MutableMapping, List, Dict, Any, Optional\n\nfrom bb_logger import LoggableComponent, TLogRouterMixin, LOG_ROUTER\n\n# –í –Ω–∞—á–∞–ª–æ bb_sys.py –¥–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç—ã\nfrom bb_events import (\n    TEvent, TEventType, TSubscription, TSubscriptionIndex,\n    TwsDataChannel, TwsChannelSubscription, TwsChannelData, TwsChannelSubscriptionIndex,\n    create_tick_event, create_status_event, create_ui_command,\n    create_tick_channel_data, create_candle_channel_data\n)\n\n\n# --- –ü–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∞–µ–º–∞—è ENV-–º–∞–ø–∞ ---\n_ENV: MutableMapping[str, str] = os.environ\n\ndef set_env_mapping(mapping: MutableMapping[str, str] | None) -> None:\n    global _ENV\n    _ENV = os.environ if mapping is None else mapping\n\ndef get_env_mapping() -> MutableMapping[str, str]:\n    return _ENV\n\ndef _s(v):\n    return '' if v is None else str(v)\n\ndef _set_key(name: str, value: str) -> bool:\n    if not name:\n        return False\n    _ENV[name] = '' if value is None else _s(value)\n    return True\n\ndef _key(name: str | None, default: str = '') -> str | None:\n    if not name:\n        return None\n    v = _ENV.get(name)\n    if v is not None and v != '':\n        return v\n    _ENV[name] = str(default)\n    return str(default)\n\ndef explode(delimiter: str, src: str) -> list[str]:\n    if not src:\n        return []\n    parts = [x.strip() for x in src.replace(\";\", delimiter).replace(\",\", delimiter).split(delimiter)]\n    return [x for x in parts if x]\n\n\n# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è / –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã ---\nBYBIT_API_KEY = _key('BYBIT_API_KEY', '')\nBYBIT_API_SECRET = _key('BYBIT_API_SECRET', '')\nBYBIT_MODE = _key('BYBIT_MODE', 'prod')  # prod | test\n\nif BYBIT_MODE == 'test':\n    BYBIT_WS_PUBLIC_LINEAR = 'wss://stream-testnet.bybit.com/v5/public/linear'\n    BYBIT_REST = 'https://api-testnet.bybit.com'\nelse:\n    BYBIT_WS_PUBLIC_LINEAR = 'wss://stream.bybit.com/v5/public/linear'\n    BYBIT_REST = 'https://api.bybit.com'\n\nMSK = dt.timezone(dt.timedelta(hours=3), name='MSK')\n\nDB_CFG = {\n    'host': _key('DB_HOST', '127.0.0.1'),\n    'port': int(_key('DB_PORT', '3307')),\n    'user': _key('DB_USER', 'u267510'),\n    'password': _key('DB_PASSWORD', '_n2FeRUP.6'),\n    'database': _key('DB_NAME', 'u267510_tg'),\n    'autocommit': True,\n    'charset': _key('DB_CHARSET', 'utf8mb4'),\n}\n\nANN_URL = 'https://api.bybit.com/v5/announcements/index'\nANN_LOCALE = 'en-US'\n\nUSDT_PAIR_RE = re.compile(r'([A-Z0-9]{1,20})USDT')\nUSDT_SLASH_RE = re.compile(r'([A-Z0-9]{1,20})/USDT')\n\nBYBIT, PERP, USDT, BUY, SELL = 'BYBIT', 'PERP', 'USDT', 'BUY', 'SELL'\nTRACEBACK_ENABLED = True\nBB_ENABLE_GLOBAL_REGISTRY = int(_key('BB_ENABLE_GLOBAL_REGISTRY', '0') or '0')  # feature-flag\n\n__all__ = [\n    'TObject', 'TApplication', 'TComponent', 'TLiveComponent',\n    'TSysComponent', 'TModule',\n    'set_env_mapping', 'get_current_app', 'set_current_app',\n    '_s', '_set_key', '_key', 'explode',\n    'DB_CFG', 'BYBIT_API_KEY', 'BYBIT_API_SECRET',\n    'BYBIT_MODE', 'BYBIT_WS_PUBLIC_LINEAR', 'BYBIT_REST',\n    'MSK', 'ANN_URL', 'ANN_LOCALE',\n    'BYBIT', 'PERP', 'USDT', 'BUY', 'SELL',\n    'USDT_PAIR_RE', 'USDT_SLASH_RE'\n]\n# ---------------------------------------------------------------------\n# TObject ‚Äî –±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å\n# ---------------------------------------------------------------------\nclass TObject:\n    def __init__(self, name: str = None):\n        cname = self.__class__.__name__\n        if cname[:1].lower() == 't':\n            cname = cname[1:]\n        self.Name = name if name else cname\n        # –í TObject –Ω–µ—Ç Owner ‚Äî –æ–Ω –ø–æ—è–≤–ª—è–µ—Ç—Å—è –≤ TComponent\n\n    # --- –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å—Ç–∞—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ name ---\n    @property\n    def name(self) -> str:\n        return self.Name\n    @name.setter\n    def name(self, v: str):\n        self.Name = v\n\n    def log(self, function: str, *parts, window: int = 1):\n        project_symbol = _key('PROJECT_SYMBOL', 'BB')\n        project_version = _key('PROJECT_VERSION', '3')\n        now = datetime.now().strftime('%H:%M:%S')\n        msg = ' '.join(str(p) for p in parts)\n        text = f'[{project_symbol}_{project_version}][{now}][{self.Name}]{function}(): {msg}'\n        try:\n            if LOG_ROUTER:\n                LOG_ROUTER.write(text, window=window)\n            else:\n                print(text, flush=True)\n        except Exception:\n            print(text, flush=True)\n\n    def fail(self, function: str, msg: str, exc_type: type = Exception):\n        from bb_db import key_int\n        try:\n            trace_limit = key_int(\"TRACE_LIMIT\", 12)\n        except Exception:\n            trace_limit = 12\n\n        stack = \"\".join(traceback.format_stack(limit=trace_limit))\n        cls_name = self.__class__.__name__\n        owner_name = getattr(getattr(self, \"Owner\", None), \"Name\", None)\n        owner_part = f\"\\nüì¶ owner: {owner_name}\" if owner_name else \"\"\n        text = (f\"\\nüí• {cls_name}.{function}() FAILED{owner_part}\\n‚öôÔ∏è message: {msg}\"\n                f\"\\n\\nüß© Traceback (most recent calls):\\n{stack}\")\n        try:\n            self.log(\"fail\", msg)\n        except Exception:\n            print(f\"[{cls_name}] fail(): {msg}\")\n        try:\n            os.makedirs(\"log\", exist_ok=True)\n            with open(\"log/fail.log\", \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{text}\\n{'-'*80}\\n\")\n        except Exception:\n            pass\n        print(text, flush=True)\n        raise exc_type(f\"{cls_name}.{function}(): {msg}\")\n# ---------------------------------------------------------------------\n# –ü–æ—Ç–æ–∫–æ–≤—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è\n# ---------------------------------------------------------------------\n_app_context = threading.local()\n\ndef set_current_app(app: \"TApplication\"):\n    _app_context.current = app\n\ndef get_current_app() -> \"TApplication | None\":\n    return getattr(_app_context, \"current\", None)\n# ---------------------------------------------------------------------\n# TApplication ‚Äî —É–ø—Ä–∞–≤–ª—è—é—â–∏–π –æ–±—ä–µ–∫—Ç\n# ---------------------------------------------------------------------\nclass TApplication(TObject, TLogRouterMixin):\n    _instance = None\n\n    def __init__(self):\n        if TApplication._instance is not None:\n            raise RuntimeError(\"TApplication is a singleton. Use Application() instead.\")\n        super().__init__('Application')\n        set_current_app(self)\n\n        # –°–∏—Å—Ç–µ–º–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã\n        self.Session = None\n        self.Database = None\n        self.Config = None\n        self.Schema = None\n\n        # –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã\n        self.Components: dict[str, \"TComponent\"] = {}  # –≤–µ—Ä—Ö–Ω–µ—É—Ä–æ–≤–Ω–µ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –±–µ–∑ Owner\n        self.Modules: dict[str, \"TModule\"] = {}\n        self.Pages: dict[str, Path] = {}\n        self.ActiveModule: \"TModule | None\" = None\n\n        # –§–∞–π–ª–æ–≤—ã–µ –ø—É—Ç–∏ / —Å—Ç–∞—Ç—É—Å\n        self.root_dir = Path(__file__).parent\n        self.public_dir = self.root_dir / \"public\"\n        self.public_dir.mkdir(exist_ok=True)\n        self.start_time = datetime.now()\n\n        # –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–µ—Å—Ç—Ä –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (id -> instance)\n        self._all_components: dict[str, \"TComponent\"] = {}\n\n        self._init_log_center()\n        self.log('__init__', 'application created')\n        # +++ –°–ò–°–¢–ï–ú–ê –°–û–ë–´–¢–ò–ô –ò –ö–ê–ù–ê–õ–û–í +++\n        # –ü–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ —Å–æ–±—ã—Ç–∏—è\n        self._subscriptions = TSubscriptionIndex()\n        self._event_buffer: List[TEvent] = []\n        self._max_event_buffer_size = 10000\n\n        # –ü–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ WebSocket –∫–∞–Ω–∞–ª—ã\n        self._channel_subscriptions = TwsChannelSubscriptionIndex()\n        self._channel_sequences: Dict[TwsDataChannel, int] = {}\n        self._channel_buffer: Dict[TwsDataChannel, List[TwsChannelData]] = {}\n        self._max_channel_buffer_size = 1000\n\n        # WebSocket –∫–ª–∏–µ–Ω—Ç—ã\n        self._ws_clients: Dict[str, \"TWebSocketClient\"] = {}\n\n        # –ú–µ—Ç—Ä–∏–∫–∏\n        self._events_processed = 0\n        self._events_dropped = 0\n        self._channel_data_processed = 0\n        self._channel_data_dropped = 0\n        # --- –ö–û–ù–ï–¶ –î–û–ë–ê–í–õ–ï–ù–ò–Ø ---\n\n        self._init_log_center()\n        self.log('__init__', 'application created')\n        TApplication._instance = self\n\n    # --- –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: modules/pages/components ---\n    @property\n    def modules(self): return self.Modules\n    @modules.setter\n    def modules(self, v): self.Modules = v\n    @property\n    def pages(self): return self.Pages\n    @pages.setter\n    def pages(self, v): self.Pages = v\n    @property\n    def components(self): return self.Components\n    @components.setter\n    def components(self, v): self.Components = v\n    @property\n    def active_module(self): return self.ActiveModule\n    @active_module.setter\n    def active_module(self, v): self.ActiveModule = v\n\n    # --- Singleton access ---\n    @staticmethod\n    def app() -> \"TApplication\":\n        if TApplication._instance is None:\n            TApplication()\n        return TApplication._instance\n\n    # --- –†–µ–µ—Å—Ç—Ä –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ (feature-flagged) ---\n    def _registry_enabled(self) -> bool:\n        return bool(BB_ENABLE_GLOBAL_REGISTRY)\n\n    def register_global(self, comp: \"TComponent\") -> None:\n        if not self._registry_enabled():\n            return\n        cid = comp.id()\n        if cid in self._all_components and self._all_components[cid] is not comp:\n            comp.fail('register_global', f'duplicate id(): {cid}', ValueError)\n        self._all_components[cid] = comp\n        self.log('register_global', f'{cid}')\n\n    def unregister_global(self, comp: \"TComponent\") -> None:\n        if not self._registry_enabled():\n            return\n        cid = comp.id()\n        if self._all_components.get(cid) is comp:\n            del self._all_components[cid]\n            self.log('unregister_global', f'{cid}')\n\n    def find_by_id(self, cid: str) -> \"TComponent | None\":\n        if not self._registry_enabled():\n            return None\n        return self._all_components.get(cid)\n\n    def iter_components(self, root: \"TComponent | None\" = None):\n        stack = [root] if root else list(self.Components.values())\n        while stack:\n            node = stack.pop()\n            if not node:\n                continue\n            yield node\n            for child in node.Components.values():\n                stack.append(child)\n\n    def check_invariants(self) -> list[str]:\n        errors: list[str] = []\n        seen_ids: set[str] = set()\n        for comp in self.iter_components():\n            # 1) —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å Name –≤ Owner\n            if comp.Owner:\n                siblings = comp.Owner.Components\n                if sum(1 for n, c in siblings.items() if n == comp.Name and c is comp) != 1:\n                    errors.append(f\"[name-unique] {comp.Owner.Name} -> '{comp.Name}' not unique\")\n            # 2) –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å id()\n            try:\n                cid = comp.id()\n            except Exception as e:\n                errors.append(f\"[id()] error in {comp.Name}: {e}\")\n                continue\n            if cid in seen_ids:\n                errors.append(f\"[id-collision] {cid}\")\n            else:\n                seen_ids.add(cid)\n            # 3) —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å —Å —Ä–µ–µ—Å—Ç—Ä–æ–º\n            if self._registry_enabled():\n                if self._all_components.get(cid) is not comp:\n                    errors.append(f\"[registry-miss] {cid}\")\n        return errors\n\n    # --- –ü—Ä–æ—á–µ–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ API ---\n    def register_module(self, mod: \"TModule\"):\n        self.Modules[mod.tag] = mod\n        self.ActiveModule = mod\n        self.log('register_module', f'{mod.tag} registered')\n\n    def unregister_module(self, mod: \"TModule\"):\n        if mod.tag in self.Modules:\n            del self.Modules[mod.tag]\n            self.log('unregister_module', f'{mod.tag} unregistered')\n        if self.ActiveModule == mod:\n            self.ActiveModule = None\n\n    def close(self):\n        self.log('close', 'closing all modules...')\n        for mod in list(self.Modules.values()):\n            try:\n                mod.stop()\n            except Exception as e:\n                self.log('close', f'error stopping {mod.tag}: {e}')\n        self.Modules.clear()\n        self.ActiveModule = None\n        print(\"üé¨ The End ‚Äî Application closed gracefully.\")\n\n    def __repr__(self):\n        return f\"<TApplication {self.project_tag}, modules={len(self.Modules)}>\"\n\n    def _init_log_center(self):\n        try:\n            from bb_logger import init_log_router, LOG_ROUTER\n            init_log_router()\n            if LOG_ROUTER:\n                self.log(\"Application\", \"log center initialized\", window=1)\n            else:\n                print(\"ü™∂ [Fallback] Plain console logger active\", flush=True)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è [LoggerInit] failed: {e}\", flush=True)\n\n    # --- –°–≤–æ–π—Å—Ç–≤–∞ –ø—Ä–æ–µ–∫—Ç–∞ ---\n    @property\n    def project(self) -> str:\n        return _key('PROJECT', 'CRYPTO_MOWER')\n    @property\n    def project_version(self) -> str:\n        return _key('PROJECT_VERSION', '3')\n    @property\n    def project_tag(self) -> str:\n        return f'{self.project}{self.project_version}'\n\n    # --- –¢–æ—á–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤–µ—Ä—Ö–Ω–µ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ ---\n    def register(self, comp: \"TComponent\"):\n        name = getattr(comp, \"Name\", comp.__class__.__name__)\n        if name in self.Components and self.Components[name] is not comp:\n            # –ñ—ë—Å—Ç–∫–∞—è –∑–∞—â–∏—Ç–∞: –Ω–µ –¥–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –Ω–∞ –≤–µ—Ä—Ö–Ω–µ–º —É—Ä–æ–≤–Ω–µ\n            comp.fail('register', f\"Duplicate top-level component Name: {name}\", ValueError)\n        self.Components[name] = comp\n        self.log(\"register\", f\"component {name}\")\n        try:\n            self.register_global(comp)\n        except Exception as e:\n            self.log(\"register\", f\"‚ö†Ô∏è registry skipped: {e}\")\n        return True\n\n    # --- –í–∏–∑—É–∞–ª—å–Ω–æ–µ (–±–∞–∑–æ–≤—ã–π —Å—Ç–∏–ª—å, –æ—Å—Ç–∞–≤–ª–µ–Ω–æ –∫–∞–∫ –±—ã–ª–æ) ---\n    def base_style(self) -> str:\n        return \"\"\"\n        body {font-family:monospace;background:#0f1117;color:#00ff88;margin:0;padding:10px;}\n        h1 {color:#00ff88;}\n        #log {white-space:pre-wrap;background:#1a1d29;padding:10px;border-radius:8px;overflow-y:auto;height:80vh;}\n        button {background:#1a1d29;color:#00ff88;border:1px solid #00ff88;border-radius:6px;padding:6px 12px;cursor:pointer;}\n        button:hover {background:#00ff8840;}\n        \"\"\"\n\n    # --- –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: —Å—Ç–∞—Ä—ã–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã ---\n    def echo(self, msg: str):\n        print(msg)\n\n    # -------------------------------------------------------------\n    # Page Auto-generation Interface (–¥–ª—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ—Ç–æ–º–∫–∞–º–∏)\n    # -------------------------------------------------------------\n    def ensure_page_auto(self, force: bool = False):\n        \"\"\"\n        –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –º–µ—Ö–∞–Ω–∏–∑–º –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü.\n        –î–µ–ª–µ–≥–∏—Ä—É–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ—Ç–æ–º–∫–∞–º —á–µ—Ä–µ–∑ generate_page() –∏ generate_name().\n        –ü–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Ñ–∞–π–ª, –µ—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç –∏–∑–º–µ–Ω–∏–ª—Å—è.\n        \"\"\"\n        try:\n            content = self.generate_page()\n            name = self.generate_name()\n\n            if not content:\n                self.log(\"ensure_page_auto\", f\"‚ö†Ô∏è no content generated for {name}\")\n                return None\n\n            path = self.root_dir / name\n            write_needed = force or not path.exists()\n\n            # –ø—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª—Å—è –ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç\n            if not write_needed:\n                try:\n                    existing = path.read_text(encoding=\"utf-8\")\n                    if existing != content:\n                        write_needed = True\n                except Exception:\n                    write_needed = True\n\n            if write_needed:\n                path.write_text(content, encoding=\"utf-8\")\n                self.log(\"ensure_page_auto\", f\"‚úÖ updated {path}\")\n            else:\n                self.log(\"ensure_page_auto\", f\"‚ÑπÔ∏è no changes in {path}\")\n\n            self.pages[name] = path\n            return path\n\n        except Exception as e:\n            self.log(\"ensure_page_auto\", f\"‚ùå failed: {e}\")\n            return None\n\n    def generate_page(self) -> str:\n        \"\"\"\n        –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å ‚Äî –ø–æ—Ç–æ–º–æ–∫ –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å HTML-—Å–æ–¥–µ—Ä–∂–∏–º–æ–µ.\n        \"\"\"\n        self.log(\"generate_page\", \"no implementation in base class\")\n        return \"\"\n\n    def generate_name(self) -> str:\n        \"\"\"\n        –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å ‚Äî –ø–æ—Ç–æ–º–æ–∫ –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å –∏–º—è HTML-—Ñ–∞–π–ª–∞.\n        –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–∑ –∏–º–µ–Ω–∏ .py-—Ñ–∞–π–ª–∞ –∫–ª–∞—Å—Å–∞.\n        \"\"\"\n        try:\n            import inspect\n            path = Path(inspect.getfile(self.__class__))\n            return f\"{path.stem}.html\"\n        except Exception:\n            return f\"{self.__class__.__name__}.html\"\n\n    # -------------------------------------------------------------\n    # Compatibility\n    # ------------------------------------------------------------\n\n    def register(self, comp):\n        name = getattr(comp, \"name\", comp.__class__.__name__)\n        self.log(\"register\", f\"component {name} (stub)\")\n        return True\n\n    ##00e0ff\n    def base_style(self) -> str:\n        \"\"\"–ì–ª–æ–±–∞–ª—å–Ω—ã–π CSS –¥–ª—è –≤—Å–µ—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.\"\"\"\n        return \"\"\"\n        body {\n          font-family: monospace;\n          background: #0f1117;\n          color: #00ff88;\n          margin: 0;\n          padding: 10px;\n        }\n        h1 { color: #00ff88; } \n        #log {\n          white-space: pre-wrap;\n          background: #1a1d29;\n          padding: 10px;\n          border-radius: 8px;\n          overflow-y: auto;\n          height: 80vh;\n        }\n        button {\n          background:#1a1d29;\n          color:#00ff88;\n          border:1px solid #00ff88;\n          border-radius:6px;\n          padding:6px 12px;\n          cursor:pointer;\n          font-family:monospace;\n        }\n        button:hover {\n          background:#00ff8840;\n        }\n        \"\"\"\n\n    # +++ –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° –°–û–ë–´–¢–ò–Ø–ú–ò +++\n\n    def subscribe(self, target_id: str, topic: str, **filters) -> bool:\n        \"\"\"–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–∞ —Å–æ–±—ã—Ç–∏—è –ø–æ —Ç–µ–º–µ —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏\"\"\"\n        try:\n            subscription = TSubscription(\n                target_id=target_id,\n                topic=topic,\n                filters=filters\n            )\n            self._subscriptions.add(subscription)\n            self.log('subscribe', f'{target_id} -> {topic} {filters}')\n            return True\n        except Exception as e:\n            self.log('subscribe', f'ERROR: {e}')\n            return False\n\n    def unsubscribe(self, target_id: str, topic: str = None) -> bool:\n        \"\"\"–û—Ç–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –æ—Ç —Å–æ–±—ã—Ç–∏–π\"\"\"\n        try:\n            if topic:\n                # –£–¥–∞–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ç–µ–º—ã\n                subs_to_remove = [\n                    sub for sub in self._subscriptions._all_subscriptions\n                    if sub.target_id == target_id and sub.topic == topic\n                ]\n                for sub in subs_to_remove:\n                    self._subscriptions._all_subscriptions.remove(sub)\n                    self._subscriptions._subscriptions[topic].remove(sub)\n            else:\n                # –£–¥–∞–ª—è–µ–º –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è target_id\n                self._subscriptions.remove_by_target(target_id)\n\n            self.log('unsubscribe', f'{target_id} from {topic or \"all topics\"}')\n            return True\n        except Exception as e:\n            self.log('unsubscribe', f'ERROR: {e}')\n            return False\n\n    def handle_event(self, event: TEvent) -> bool:\n        \"\"\"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–±—ã—Ç–∏–µ - –Ω–∞—Ö–æ–¥–∏—Ç –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –∏ —É–≤–µ–¥–æ–º–ª—è–µ—Ç –∏—Ö\"\"\"\n        try:\n            # –î–æ–±–∞–≤–ª—è–µ–º –≤ –±—É—Ñ–µ—Ä\n            self._event_buffer.append(event)\n            if len(self._event_buffer) > self._max_event_buffer_size:\n                self._event_buffer.pop(0)\n                self._events_dropped += 1\n\n            # –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\n            matching_subs = self._subscriptions.find(event)\n            if not matching_subs:\n                return False\n\n            # –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\n            notified_count = 0\n            for sub in matching_subs:\n                comp = self.find_by_id(sub.target_id)\n                if comp and hasattr(comp, 'on_event'):\n                    try:\n                        comp.on_event(event)\n                        notified_count += 1\n                    except Exception as e:\n                        self.log('handle_event', f'ERROR in {comp.Name}.on_event(): {e}')\n\n            self._events_processed += 1\n            if self._events_processed % 1000 == 0:\n                self.log('handle_event',\n                         f'processed {self._events_processed} events, dropped {self._events_dropped}')\n\n            return notified_count > 0\n\n        except Exception as e:\n            self.log('handle_event', f'CRITICAL ERROR: {e}')\n            return False\n\n    # +++ –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° WS –ö–ê–ù–ê–õ–ê–ú–ò +++\n\n    def subscribe_channel(self, target_id: str, channel: TwsDataChannel,\n                          symbols: List[str] = None, **filters) -> bool:\n        \"\"\"–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–∞ WebSocket –∫–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö\"\"\"\n        try:\n            subscription = TwsChannelSubscription(\n                target_id=target_id,\n                channel=channel,\n                symbols=symbols or [],\n                filters=filters\n            )\n            self._channel_subscriptions.add(subscription)\n            self.log('subscribe_channel', f'{target_id} -> {channel.value} symbols={symbols}')\n            return True\n        except Exception as e:\n            self.log('subscribe_channel', f'ERROR: {e}')\n            return False\n\n    def unsubscribe_channel(self, target_id: str, channel: TwsDataChannel = None) -> bool:\n        \"\"\"–û—Ç–ø–∏—Å—ã–≤–∞–µ—Ç –æ—Ç WebSocket –∫–∞–Ω–∞–ª–∞(–æ–≤)\"\"\"\n        try:\n            if channel:\n                # –£–¥–∞–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞\n                subs_to_remove = [\n                    sub for sub in self._channel_subscriptions._all_subscriptions\n                    if sub.target_id == target_id and sub.channel == channel\n                ]\n                for sub in subs_to_remove:\n                    self._channel_subscriptions._all_subscriptions.remove(sub)\n                    self._channel_subscriptions._channel_subscriptions[channel].remove(sub)\n            else:\n                # –£–¥–∞–ª—è–µ–º –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è target_id\n                self._channel_subscriptions.remove_by_target(target_id)\n\n            self.log('unsubscribe_channel', f'{target_id} from {channel or \"all channels\"}')\n            return True\n        except Exception as e:\n            self.log('unsubscribe_channel', f'ERROR: {e}')\n            return False\n\n    def handle_channel_data(self, data_point: TwsChannelData) -> bool:\n        \"\"\"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–æ—á–∫—É –¥–∞–Ω–Ω—ã—Ö –∏–∑ WebSocket –∫–∞–Ω–∞–ª–∞\"\"\"\n        try:\n            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å\n            channel = data_point.channel\n            if channel not in self._channel_sequences:\n                self._channel_sequences[channel] = 0\n            self._channel_sequences[channel] += 1\n\n            data_point.sequence = self._channel_sequences[channel]\n\n            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±—É—Ñ–µ—Ä –∫–∞–Ω–∞–ª–∞\n            if channel not in self._channel_buffer:\n                self._channel_buffer[channel] = []\n            self._channel_buffer[channel].append(data_point)\n\n            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞\n            buffer = self._channel_buffer[channel]\n            if len(buffer) > self._max_channel_buffer_size:\n                buffer.pop(0)\n                self._channel_data_dropped += 1\n\n            # –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\n            matching_subs = self._channel_subscriptions.find(data_point)\n            if not matching_subs:\n                return False\n\n            # –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\n            notified_count = 0\n            for sub in matching_subs:\n                comp = self.find_by_id(sub.target_id)\n                if comp and hasattr(comp, 'on_channel_data'):\n                    try:\n                        comp.on_channel_data(data_point.channel, data_point)\n                        notified_count += 1\n                    except Exception as e:\n                        self.log('handle_channel_data', f'ERROR in {comp.Name}.on_channel_data(): {e}')\n\n            self._channel_data_processed += 1\n            if self._channel_data_processed % 1000 == 0:\n                self.log('handle_channel_data',\n                         f'processed {self._channel_data_processed} channel points, dropped {self._channel_data_dropped}')\n\n            return notified_count > 0\n\n        except Exception as e:\n            self.log('handle_channel_data', f'CRITICAL ERROR: {e}')\n            return False\n\n    # +++ –ú–ï–¢–û–î–´ –î–õ–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø WS –ö–õ–ò–ï–ù–¢–ê–ú–ò +++\n\n    def add_ws_client(self, name: str, client: \"TWebSocketClient\") -> bool:\n        \"\"\"–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç WebSocket –∫–ª–∏–µ–Ω—Ç –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏\"\"\"\n        if name in self._ws_clients:\n            self.log('add_ws_client', f'ERROR: client {name} already exists')\n            return False\n\n        self._ws_clients[name] = client\n        self.log('add_ws_client', f'registered {name}')\n        return True\n\n    def remove_ws_client(self, name: str) -> bool:\n        \"\"\"–£–¥–∞–ª—è–µ—Ç WebSocket –∫–ª–∏–µ–Ω—Ç\"\"\"\n        if name in self._ws_clients:\n            del self._ws_clients[name]\n            self.log('remove_ws_client', f'removed {name}')\n            return True\n        return False\n\n    # +++ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ +++\n\n    def get_event_history(self, limit: int = 100) -> List[TEvent]:\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é —Å–æ–±—ã—Ç–∏–π\"\"\"\n        return self._event_buffer[-limit:] if limit > 0 else self._event_buffer\n\n    def get_channel_history(self, channel: TwsDataChannel, limit: int = 100) -> List[TwsChannelData]:\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é –¥–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–∞\"\"\"\n        buffer = self._channel_buffer.get(channel, [])\n        return buffer[-limit:] if limit > 0 else buffer\n\n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã —Å–æ–±—ã—Ç–∏–π\"\"\"\n        return {\n            \"events_processed\": self._events_processed,\n            \"events_dropped\": self._events_dropped,\n            \"subscriptions_count\": self._subscriptions.count(),\n            \"event_buffer_size\": len(self._event_buffer),\n            \"ws_clients_count\": len(self._ws_clients)\n        }\n\n    def get_channel_metrics(self) -> Dict[str, Any]:\n        \"\"\"–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã –∫–∞–Ω–∞–ª–æ–≤\"\"\"\n        return {\n            \"channel_data_processed\": self._channel_data_processed,\n            \"channel_data_dropped\": self._channel_data_dropped,\n            \"channel_subscriptions_count\": self._channel_subscriptions.count(),\n            \"active_channels\": list(self._channel_buffer.keys()),\n            \"channel_buffer_sizes\": {chan.value: len(buf) for chan, buf in self._channel_buffer.items()}\n        }\n# ---------------------------------------------------------------------\n# TComponent ‚Äî –±–∞–∑–æ–≤—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç Tradition\n# ---------------------------------------------------------------------\nclass TComponent(TObject):\n    def __init__(self, Owner: \"TComponent | None\" = None, name: str = None):\n        # name —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –∫–∞–∫ Name –≤ TObject\n        super().__init__(name)\n        # –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n        self.Owner: \"TComponent | None\" = Owner\n        self.Components: dict[str, \"TComponent\"] = {}\n\n        # –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è\n        app = None\n        try:\n            app = TApplication.app()\n        except Exception:\n            app = None\n\n        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ Owner –∏–ª–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è\n        if self.Owner is not None:\n            self._register_in_owner(self.Owner)\n        elif app:\n            app.register(self)\n\n        self.log('__init__', f'component {self.Name} created')\n\n    # --- –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: owner/components (–∞–ª–∏–∞—Å—ã) ---\n    @property\n    def owner(self): return self.Owner\n    @owner.setter\n    def owner(self, v): self.Owner = v\n    @property\n    def components(self): return self.Components\n    @components.setter\n    def components(self, v): self.Components = v\n\n    # --- –†–æ–¥–æ—Å–ª–æ–≤–Ω–∞—è (–≤—Å–µ–≥–¥–∞ —Å –º–∞–ª–µ–Ω—å–∫–æ–π) ---\n    def id(self) -> str:\n        path = [self.Name]\n        p = self.Owner\n        guard = 0\n        while p is not None and guard < 1024:\n            path.append(p.Name)\n            p = getattr(p, \"Owner\", None)\n            guard += 1\n        if guard >= 1024:\n            self.fail('id', 'possible ownership cycle detected', RuntimeError)\n        return \"-\".join(reversed(path))\n\n    # --- –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É –≤–ª–∞–¥–µ–ª—å—Ü–∞ ---\n    def _register_in_owner(self, owner: \"TComponent\"):\n        if self.Name in owner.Components and owner.Components[self.Name] is not self:\n            self.fail('_register_in_owner', f'Duplicate subcomponent Name: {self.Name}', ValueError)\n        owner.Components[self.Name] = self\n        self.log('_register_in_owner', f'registered in {owner.Name}')\n        app = get_current_app()\n        if app:\n            try:\n                app.register_global(self)\n            except Exception as e:\n                self.log('_register_in_owner', f'‚ö†Ô∏è registry skipped: {e}')\n\n    def _unregister_from_owner(self):\n        if not self.Owner:\n            return\n        if self.Name in self.Owner.Components and self.Owner.Components[self.Name] is self:\n            del self.Owner.Components[self.Name]\n            self.log('_unregister_from_owner', f'unregistered from {self.Owner.Name}')\n        self.Owner = None\n\n    # --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ—á–µ—Ä–Ω–∏–º–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ ---\n    def add(self, comp: \"TComponent\"):\n        if comp.Name in self.Components and self.Components[comp.Name] is not comp:\n            self.fail('add', f'Duplicate component Name: {comp.Name}', ValueError)\n        self.Components[comp.Name] = comp\n        comp.Owner = self\n        self.log('add', f'{comp.Name} added')\n        app = get_current_app()\n        if app:\n            try:\n                app.register_global(comp)\n            except Exception as e:\n                self.log('add', f'‚ö†Ô∏è registry skipped: {e}')\n\n    def remove(self, comp: \"TComponent\"):\n        if comp.Name not in self.Components:\n            self.fail('remove', f'Component not found: {comp.Name}', KeyError)\n        del self.Components[comp.Name]\n        self.log('remove', f'{comp.Name} removed')\n        # –¥–µ—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ ‚Äî –ø—Ä–∏ free()\n\n    def find(self, name: str):\n        return self.Components.get(name)\n\n    def list(self):\n        return list(self.Components.keys())\n\n    # --- –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª ---\n    def free(self):\n        self.log('free', f'freeing {len(self.Components)} subcomponents...')\n        for sub in list(self.Components.values()):\n            if hasattr(sub, 'free'):\n                sub.free()\n        self.Components.clear()\n        app = get_current_app()\n        if app:\n            try:\n                app.unregister_global(self)\n            except Exception as e:\n                self.log('free', f'‚ö†Ô∏è registry skipped: {e}')\n        self._unregister_from_owner()\n        self.log('free', 'component destroyed')\n\n    # +++ –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° –°–û–ë–´–¢–ò–Ø–ú–ò –ò –ö–ê–ù–ê–õ–ê–ú–ò +++\n\n    def subscribe_event(self, topic: str, **filters):\n        \"\"\"–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –æ–¥–∏–Ω–æ—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è\"\"\"\n        app = get_current_app()\n        if app and hasattr(app, 'subscribe'):\n            app.subscribe(self.id(), topic, **filters)\n            self.log('subscribe_event', f'subscribed to {topic} {filters}')\n        else:\n            self.log('subscribe_event', 'app not found or no subscription support')\n\n    def unsubscribe_event(self, topic: str = None):\n        \"\"\"–û—Ç–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –æ—Ç —Å–æ–±—ã—Ç–∏–π\"\"\"\n        app = get_current_app()\n        if app and hasattr(app, 'unsubscribe'):\n            app.unsubscribe(self.id(), topic)\n            self.log('unsubscribe_event', f'unsubscribed from {topic or \"all events\"}')\n        else:\n            self.log('unsubscribe_event', 'app not found')\n\n    def subscribe_channel(self, channel: TwsDataChannel, symbols: List[str] = None, **filters):\n        \"\"\"–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ WebSocket –∫–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö\"\"\"\n        app = get_current_app()\n        if app and hasattr(app, 'subscribe_channel'):\n            app.subscribe_channel(self.id(), channel, symbols, **filters)\n            self.log('subscribe_channel', f'subscribed to {channel.value} symbols={symbols}')\n        else:\n            self.log('subscribe_channel', 'app not found or no channel support')\n\n    def unsubscribe_channel(self, channel: TwsDataChannel = None):\n        \"\"\"–û—Ç–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –æ—Ç WebSocket –∫–∞–Ω–∞–ª–∞(–æ–≤)\"\"\"\n        app = get_current_app()\n        if app and hasattr(app, 'unsubscribe_channel'):\n            app.unsubscribe_channel(self.id(), channel)\n            self.log('unsubscribe_channel', f'unsubscribed from {channel or \"all channels\"}')\n        else:\n            self.log('unsubscribe_channel', 'app not found')\n\n    def on_event(self, event: TEvent):\n        \"\"\"\n        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–¥–∏–Ω–æ—á–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ.\n        –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –≤ –ø–æ—Ç–æ–º–∫–∞—Ö –¥–ª—è —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —Å–æ–±—ã—Ç–∏—è.\n        \"\"\"\n        self.log('on_event', f'received {event.type} from {event.source}')\n\n    def on_channel_data(self, channel: TwsDataChannel, data_point: TwsChannelData):\n        \"\"\"\n        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–æ—á–∫—É –¥–∞–Ω–Ω—ã—Ö –∏–∑ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞.\n        –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –≤ –ø–æ—Ç–æ–º–∫–∞—Ö –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ—Ç–æ–∫–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö.\n        \"\"\"\n        self.log('on_channel_data', f'received {channel.value} #{data_point.sequence} for {data_point.symbol}')\n# ---------------------------------------------------------------------\n# TLiveComponent ‚Äî ‚Äú–∂–∏–≤–æ–π‚Äù –∫–æ–º–ø–æ–Ω–µ–Ω—Ç\n# ---------------------------------------------------------------------\nclass TLiveComponent(TComponent, LoggableComponent):\n    def __init__(self, Owner: \"TComponent | None\" = None, name: str = None):\n        super().__init__(Owner, name)\n\n        self._active = False\n        self._thread = None\n        self._stop = False\n\n        # Delphi-style hooks\n        self.AfterCreate = None\n        self.BeforeDestroy = None\n        self.BeforeOpen = None\n        self.AfterOpen = None\n        self.BeforeClose = None\n        self.AfterClose = None\n        self.OnError = None\n\n        try:\n            if callable(self.AfterCreate):\n                self.AfterCreate(self)\n        except Exception as e:\n            self.log(\"__init__\", f\"‚ö†Ô∏è AfterCreate error: {e}\")\n\n        self.log(\"__init__\", \"live component created\")\n\n    # –ü—É–±–ª–∏—á–Ω—ã–π API\n    def open(self):\n        if callable(self.BeforeOpen):\n            self.BeforeOpen(self)\n        result = self.do_open()\n        if result:\n            self._active = True\n            self.log(\"open\", \"component activated\")\n        else:\n            self.fail(\"open\", \"do_open() returned False\", RuntimeError)\n        if callable(self.AfterOpen):\n            self.AfterOpen(self)\n\n    def close(self):\n        try:\n            if callable(self.BeforeClose):\n                self.BeforeClose(self)\n            if self.do_close():\n                self._active = False\n                self.log(\"close\", \"component deactivated\")\n            if callable(self.AfterClose):\n                self.AfterClose(self)\n        except Exception as e:\n            self.log(\"close\", f\"‚ö†Ô∏è failed: {e}\")\n            if callable(self.OnError):\n                self.OnError(self, e)\n            else:\n                self.fail(\"close\", f\"failed: {e}\", type(e))\n\n    # –í–∏—Ä—Ç—É–∞–ª—ã\n    def do_open(self) -> bool:\n        return True\n\n    def do_close(self) -> bool:\n        return True\n\n    # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π free()\n    def free(self):\n        try:\n            if callable(self.BeforeDestroy):\n                self.BeforeDestroy(self)\n        except Exception as e:\n            self.log(\"free\", f\"‚ö†Ô∏è BeforeDestroy error: {e}\")\n\n        if getattr(self, \"_active\", False):\n            try:\n                self.close()\n            except Exception as e:\n                self.log(\"free\", f\"‚ö†Ô∏è auto-close failed: {e}\")\n\n        super().free()\n        self.log(\"free\", \"component destroyed\")\n\n    # –£–¥–æ–±–Ω—ã–µ –∞–ª–∏–∞—Å—ã\n    def run(self, *args, **kwargs):\n        self.open()\n\n    def stop(self, *args, **kwargs):\n        self.close()\n\n    # –°–≤–æ–π—Å—Ç–≤–∞\n    @property\n    def active(self) -> bool:\n        return self._active\n    @active.setter\n    def active(self, value: bool):\n        self._active = bool(value)\n# ---------------------------------------------------------------------\n# TSysComponent ‚Äî —Å–∏—Å—Ç–µ–º–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç (singleton per class)\n# ---------------------------------------------------------------------\nclass TSysComponent(TLiveComponent):\n    _instances: dict[type, \"TSysComponent\"] = {}\n\n    def __init__(self, Owner: \"TApplication\", name: str):\n        if not isinstance(Owner, TApplication):\n            raise TypeError(f\"{self.__class__.__name__} Owner must be TApplication\")\n\n        cls = self.__class__\n        if cls in TSysComponent._instances:\n            raise RuntimeError(f\"{cls.__name__} already instantiated\")\n\n        super().__init__(Owner, name)\n        TSysComponent._instances[cls] = self\n        self.log(\"__init__\", \"system component created\")\n\n    def do_open(self) -> bool:\n        return True\n\n    def do_close(self) -> bool:\n        return True\n\n    @classmethod\n    def instance(cls) -> \"TSysComponent | None\":\n        return TSysComponent._instances.get(cls)\n\n    @classmethod\n    def is_active(cls) -> bool:\n        inst = TSysComponent._instances.get(cls)\n        return bool(inst and inst._active)\n# ---------------------------------------------------------------------\n# TModule ‚Äî –º–æ–¥—É–ª—å –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è\n# ---------------------------------------------------------------------\nclass TModule(TLiveComponent):\n    def __init__(self, Owner: \"TApplication\", name: str, version: str | int = \"1\"):\n        if not isinstance(Owner, TApplication):\n            raise TypeError(\"TModule Owner must be TApplication\")\n\n        tag = f\"{name}_{version}\"\n        super().__init__(Owner, tag)\n\n        self.base_name = str(name).upper()\n        self.version = str(version)\n\n        if hasattr(Owner, \"register_module\"):\n            Owner.register_module(self)\n\n        self.log(\"__init__\", f\"{self.base_name} v{self.version} initialized\")\n\n    @property\n    def tag(self) -> str:\n        return f\"{self.base_name}_{self.version}\"\n\n    @property\n    def full_tag(self) -> str:\n        return f\"{self.Owner.project_tag}/{self.tag}\"\n\n    def do_open(self) -> bool:\n        self.Owner.register_module(self)\n        self.log(\"do_open\", f\"{self.tag} opened\")\n        return True\n\n    def do_close(self) -> bool:\n        self.Owner.unregister_module(self)\n        self.log(\"do_close\", f\"{self.tag} closed\")\n        return True\n# =====================================================================\n# bb_sys.py üúÇ The End ‚Äî See You Next Session 2025 ‚öôÔ∏è 1056\n# =====================================================================\n"
    }
  ]
}