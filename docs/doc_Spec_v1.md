# Tradition Core 2025 — mark() / debug highlighting spec v1

> Статус: утверждено Учителем.
> Назначение: единые правила раскраски debug-рамок, бейджа и поведения `.mark()` для всех визуальных контролов.

---

## 1. Семейства (family)

Каждый визуальный контрол принадлежит (или не принадлежит) логическому семейству.
Семейство определяет дерево вложенности и то, как работает mark()/рамки/бейджи.

### GRID family

* `TGrid` → уровень 0 (корень)
* `TGrid_Tr` → уровень 1
* `TGrid_Td` → уровень 2

### CARD family

* `TCard` → уровень 0 (корень)
* `TPanel(type=ptHeader)` → уровень 1
* `TPanel(type=ptFooter)` → уровень 1
* `TPanel(type=ptStatus)` → уровень 1

(У CARD только два уровня глубины: 0 и 1. Все панели header/footer/status — это один и тот же уровень 1.)

### MENU family (план)

* `TMenu` → уровень 0 (корень)
* `TMenuItem` / `TMenuButton` / `TMenuTab` → уровень 1

(Тоже двухуровневая структура: меню и его элементы.)

### TABLE family (план)

* `TTable` → уровень 0 (корень)
* `TTable_Head` / `TTable_Row` → уровень 1
* `TTable_Cell` → уровень 2

(Похоже на GRID по глубине.)

### FORM family (план)

* `TForm` → уровень 0 (корень)
* `TFormRow` / `TFormGroup` → уровень 1
* `TFormField` / `TInput` / `TSelect` / `TToggle` → уровень 2

(Тоже трёхуровневое дерево.)

Если контрол не принадлежит ни одному семейству, он считается одиночным (семейство = None) и не подсвечивается чужой палитрой.

---

## 2. Оттенки внутри палитры

У нас есть палитра из трёх насыщенностей (одного цвета):

* `light`
* `mid`
* `bright`

Каждая семья определяет, какой уровень получает какой оттенок.

### GRID

* уровень 0 (TGrid)      → `light`
* уровень 1 (TGrid_Tr)   → `mid`
* уровень 2 (TGrid_Td)   → `bright`

### CARD

* уровень 0 (TCard)                                      → `light`
* уровень 1 (TPanel ptHeader / ptFooter / ptStatus)      → `bright`

  * ВАЖНО: `mid` для карточной семьи не используется на рамках.

### MENU (план)

* уровень 0 (TMenu)      → `light`
* уровень 1 (TMenuItem / Button / Tab) → `bright`

  * Аналог CARD: только `light` + `bright`, без `mid`.

### TABLE (план)

* уровень 0 (TTable)            → `light`
* уровень 1 (Head/Row)          → `mid`
* уровень 2 (Cell)              → `bright`

### FORM (план)

* уровень 0 (TForm)             → `light`
* уровень 1 (FormRow/Group)     → `mid`
* уровень 2 (Field/Input/etc.)  → `bright`

Итого правило:

* семьи с 3 уровнями (GRID / TABLE / FORM) используют `light` → `mid` → `bright`.
* семьи с 2 уровнями (CARD / MENU) используют только `light` и `bright`.

`bright` = самая жирная рамка, `light` = самая бледная. `mid` — средняя насыщенность.

---

## 3. Палитры цветов

Палитра — это не один цвет, а тройка оттенков (`light`, `mid`, `bright`) одного тона.

Поддерживаемые имена палитр:

* `red`
* `green`
* `purple`
* `darkgray`
* `teal`
* `aqua`

Каждой палитре соответствуют 3 rgba-цвета.
Пример (идея):

* teal.light
* teal.mid
* teal.bright

Важно: палитра выбирается для СЕМЬИ целиком, не для отдельного дочернего элемента.

---

## 4. .mark(color)

`.mark(color_name: str | None)` вызывается на корне семьи (уровень 0):

* `TGrid.mark()`
* `TCard.mark()`
* в будущем `TTable.mark()`, `TForm.mark()`, `TMenu.mark()` и т.д.

Правила:

1. Если `color_name` не задан:

   * Берём «следующую свободную палитру» по циклу:
     `red → green → purple → darkgray → teal → aqua → red → ...`

2. Если `color_name` задан (например `"teal"`):

   * Если палитра известна — принудительно используем её.
   * Если палитра неизвестна — делаем fallback: берём ту же «следующую по циклу», как в (1).

3. Выбранная палитра вешается на корень семьи и распространяется на всю семью.
   Пример:

   * `card.mark("teal")` → вся семья CARD (карточка и её header/footer/status) используют teal.
   * `grid.mark("green")` → вся семья GRID (grid/row/cell) используют green.

4. Если кто-то случайно вызовет `.mark()` на не-корне семьи (например на `TPanel(ptHeader)`):

   * движок логически поднимется к ближайшему предку того же семейства (т.е. к `TCard`) и будет считать именно его корнем.
   * мы не порождаем вторую палитру внутри одной карточки.

---

## 5. Рамки и область подсветки

1. Компонент получает пунктирную рамку ТОЛЬКО если:

   * он принадлежит семейству `X`,
   * и это семейство `X` сейчас помечено `.mark()` где-то наверху,
   * и у него есть уровень (0/1/2) в этом семействе.

2. Цвет рамки = оттенок палитры по (семейство, уровень):

   * GRID: 0→light, 1→mid, 2→bright
   * CARD: 0→light, 1→bright
   * MENU: 0→light, 1→bright
   * TABLE: 0→light, 1→mid, 2→bright
   * FORM: 0→light, 1→mid, 2→bright

3. Семейства не лезут друг в друга:

   * Если подсвечен GRID, то CARD не красится и наоборот.
   * Пример: `TCard` внутри ячейки грида остаётся без зелёной рамки грида.

---

## 6. Badge (бейджик с именем)

Бейдж рисуем только у корня семьи (уровень 0). Примеры:

* у `TGrid`, если вызвали `grid.mark()`
* у `TCard`, если вызвали `card.mark()`

У дочерних элементов (строка грида, ячейка грида, header/footer панели карточки и т.п.) бейджа нет.

Стиль бейджа:

* позиция: `position:absolute; top:-2px; left:-2px;`
* фон бейджа = оттенок `light` текущей палитры семьи
* рамка бейджа = оттенок `mid` текущей палитры семьи

  * даже если семейство само не использует `mid` (как CARD / MENU), для рамки бейджа `mid` всё равно берём из палитры
* шрифт: моноширинный, жирный, ~13px
* текст: тёмный (чёрный / очень тёмно-серый)
* радиус угла: `border-radius:6px`
* pointer-events:none (чтобы не перехватывать клики)

---

## 7. Встроенные хуки для классов

Каждый визуальный класс должен уметь ответить на два вопроса.
Это нужно ядру mark(), чтобы без if-else по типам.

```python
# Возвращает строку имени семьи или None.
# Примеры: "GRID", "CARD", "MENU", "TABLE", "FORM", None

def _mark_family(self) -> str | None:
    ...

# Возвращает уровень внутри семьи (0 / 1 / 2).
# Для семейств с 2 уровнями: только 0 и 1.

def _mark_level(self) -> int:
    ...
```

Примеры:

* `TGrid` → family "GRID", level 0

* `TGrid_Tr` → family "GRID", level 1

* `TGrid_Td` → family "GRID", level 2

* `TCard` → family "CARD", level 0

* `TPanel(ptHeader)` → family "CARD", level 1

* `TPanel(ptFooter)` → family "CARD", level 1

* `TPanel(ptStatus)` → family "CARD", level 1

* `TMenu` → family "MENU", level 0

* `TMenuItem` → family "MENU", level 1

и т.д.

---

## 8. Логика ядра mark() / _resolve_mark_info()

Высокоуровнево:

1. Когда вызывается `.mark(color_name)` на корневом элементе семьи:

   * фиксируем, что эта семья теперь активна,
   * записываем, какая палитра выбрана (либо принудительно `color_name`, либо следующий цвет из цикла).

2. При рендере любого контрола:

   * определяем, есть ли у него family/level через `_mark_family()` и `_mark_level()`.
   * ищем ближайшего предка вверх по Owner, у которого стоит флаг "я — mark_root" для этой же семьи.
   * если не нашли → никакой рамки, никакого бейджа.
   * если нашли:

     * берём семейство, палитру, уровень
     * выбираем оттенок (light/mid/bright) из таблицы соответствия для этой семьи
     * рисуем пунктирный бордер `1px dashed <rgba>`
     * если это именно корень семьи (level 0 на том самом mark_root) → рисуем бейдж с именем контрола.

3. Важное правило безопасности:

   * Подсветка семьи распространяется только на элементы с тем же family.
   * Мы не красим чужих.

---

## 9. TL;DR

* mark() работает не на всём DOM сразу, а в рамках семейства.
* каждая семья знает свои уровни и какой уровень каким оттенком светить.
* CARD и MENU — двухуровневые (light / bright), GRID / TABLE / FORM — трёхуровневые (light / mid / bright).
* mark(color) поддерживает цветовые имена (`red`, `teal`, `aqua`, `darkgray`, ...). Если цвет не знаем — берём следующий из очереди.
* бейдж только у корня семьи. Корень = тот, кто вызвал mark().
* бейдж: фон=light, рамка=mid, текст моноширинный, 13px, top:-2px/left:-2px, border-radius:6px.

Это финальная договорённость, из которой уже можно безопасно пилить реализацию в TCustomControl, TGrid*, TCard, TPanel и будущие классы меню / таблиц / форм без повторных согласований.
